<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[测试文章]]></title>
      <url>https://disinuo.me/2023/04/29/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
      <content type="html"><![CDATA[<hr>
<a id="more"></a>
<hr>
<blockquote>
<p>文章标题：<a href="https://disinuo.me/2023/04/29/测试文章/" title="测试文章">测试文章</a><br>文章作者：<a href="https://disinuo.me">disinuo</a><br>文章链接：<a href="https://disinuo.me/2023/04/29/测试文章/" title="测试文章">https://disinuo.me/2023/04/29/测试文章/</a></p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[kafka机制梳理]]></title>
      <url>https://disinuo.me/2018/11/26/2018-11-26-kafka/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近我们小组在尝试搭建大数据系统，各种没听过的名词搞得我们很头大，于是准备好好弄清楚kafka到底是个什么东西~</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单来讲，kafka维护了一个消息队列，以发布-订阅的模式维护了消息发布者和接收者之间的通讯。下面看下它的主要结构吧~<br><a id="more"></a></p>
<h2 id="整体物理结构"><a href="#整体物理结构" class="headerlink" title="整体物理结构"></a>整体物理结构</h2><p><img src="/image/2018-11-26-kafka/general-physic-structure.jpg" alt></p>
<ul>
<li>三个关键的角色就是：生产者、消费者、服务器（实在不知道Broker可以咋翻译，暂且理解成服务器吧）</li>
<li>宏观来看整体流程就是：<ul>
<li>生产者往服务器中写消息</li>
<li>消费者从服务器中拿消息</li>
</ul>
</li>
</ul>
<p>具体如何写如何读，服务器如何组织消息的存储，往下看</p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>生产者发布消息，如上图所示，producer必须要指定消息的topic，topic可以理解成消息的类别，因为这个是消费者的订阅单位。partition和key是可选的这里不赘述了</p>
<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>一个broker可以理解成一个服务器节点，物理上用来存放消息队列。</p>
<h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><p>因为每条消息都属于某个topic，所以逻辑上消息是按topic存储的。而由于一个topic可能非常大，所以会分成很多个partition，那么为了负载均衡，通常一个topic的不同partition会分配到不同的borker上。具体哪个topic的哪个partition分配在哪个broker上要看开发者采用的策略。但这个是物理上的事情啦~我们等下从逻辑上分析它们和consumer之间的对应关系</p>
<h4 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h4><p>一个partition是一个队列，每个元素（消息）有一个自己的标号，称为offset。根据offset可以O(1)的查找消息。（仿佛是队列和数组的结合体~）<br>新的消息来了之后会被添加到队尾，因此partition是按照到达时间排序的有序队列</p>
<h3 id="Consumer-amp-Consumer-Group"><a href="#Consumer-amp-Consumer-Group" class="headerlink" title="Consumer &amp; Consumer Group"></a>Consumer &amp; Consumer Group</h3><p>消费者从broker获取它订阅的topic的消息。<br>一个Consumer Group里可以有多个Consumer，其实Consumer Group和Consumer之间的关系就像一个team和组员之间的关系一样。一个team要一起完成工作A(分为part1、2)、B(分为part1、2)，但是活太多了要分一下任务呀，于是组员a负责工作A的part1，组员b负责工作B的part1，组员c负责工作A、B的part2（如果两个part2比较轻松的话~）。</p>
<p>类似的，上面例子里的team就是Consumer Group，订阅消息是以group为单位的，于是上面的工作A和B就好比是Consumer Group订阅的两个topic，而两个topic分别都有两个partition。于是一共有4个partition分给3个consumer（对应例子中的组员）。</p>
<p>这样一来关系就很明确了：</p>
<ul>
<li>一个Consumer Group里的consumer们订阅的topic是一样的</li>
<li>一个consumer可以负责多个partition</li>
<li>一个partition不能对应多个consumer（同一个consumer group内）<ul>
<li>这点细说一下，因为有可能有多个consumer group订阅了同一个topic，每个consumer group的处理速度可能不一样，所以每个consumer要自己保存一个状态记录自己负责的partition读到哪了。如果在同一个consumer group内有多个consumer负责同一个partition，那么他们就要共同读写这个状态，这样维护这个状态就比较复杂（比如需要使用锁之类的）。</li>
</ul>
</li>
</ul>
<h2 id="各部分逻辑关系"><a href="#各部分逻辑关系" class="headerlink" title="各部分逻辑关系"></a>各部分逻辑关系</h2><p>由于第一张图把kafka集群当成一个黑盒，所以没有画出broker、topic、partition与producer、consumer之间的关系。为了更清楚的理解，下面的例子将他们之间的关系画出来了~</p>
<p>下例假设kafka集群中有2个broker，1个topic，这个topic有4个partition；两个consumer group，分别有2个和4个consumer，这两个consumer group都只订阅了Topic0。<br><img src="/image/2018-11-26-kafka/partition-consumer.jpg" alt><br>可以看到consumer groupA中，consumer的数量少于这个group订阅了的partition的数量，因此会有一个consumer对应多个partition的情况。<br>而consumer groupB中，二者数量刚好相等，因此每个consumer对应一个partition。<br>假如有一个consumer group的consumer数量少于其订阅的partition，那么就会有consumer闲着（前面说过不能多个consumer对应一个partition），这样的设计不好，很浪费。</p>
<h2 id="Partition副本"><a href="#Partition副本" class="headerlink" title="Partition副本"></a>Partition副本</h2><p>前面的关系梳理为了简单，忽略了副本的存在。实际上kafka为了保证数据的可靠性，会给每个partition创建多个副本存储在不同的broker上，这样一来如果某个broker突然挂掉，其他broker上与之对应的partition也能继续work~</p>
<p>下面举个例子，为了简单，例中仅有一个topic，它有2个partition，每个partition有3个副本。阴影的partition是leader，其余的都是follower<br><img src="/image/2018-11-26-kafka/partition-replicate.jpg" alt></p>
<ul>
<li>每个partition会有一个leader，其余的都是它的follower。</li>
<li>每次producer和consumer对于partition的读写都会被kafka指引到leader上（具体是如何找到leader的我就没有研究啦）</li>
<li>如果有broker挂了，比如上图中的Broker0，那么p0的leader就挂了，kafka会在p0剩下的两个follower中选一个（选举规则我也没研究）重新作为leader</li>
<li>在没有broker挂掉的平时，follower跟leader的关系有点类似consumer和partition的关系，从leader pull数据使得自己的数据与leader保持一致</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于kafka我完全是一个初学者，因此文中哪里理解的不对、描述有问题的地方欢迎评论or邮件指出！一起进步呀~~</p>
<hr>
<p>参考链接<br><a href="https://kafka.apache.org/intro" target="_blank" rel="noopener">kafka官方介绍</a><br><a href="http://kafka.apache.org/documentation.html" target="_blank" rel="noopener">Kafka官方文档</a><br><a href="http://kafka.apachecn.org/documentation.htm" target="_blank" rel="noopener">Kafka官方中文文档</a><br><a href="https://www.jianshu.com/p/6233d5341dfe" target="_blank" rel="noopener">Kafka中partition和消费者的对应关系</a><br><a href="https://hackernoon.com/thorough-introduction-to-apache-kafka-6fbf2989bbc1" target="_blank" rel="noopener">Thorough Introduction To Apache Kafka</a><br><a href="https://stackoverflow.com/questions/38024514/understanding-kafka-topics-and-partitions" target="_blank" rel="noopener">StackOverflow - Understanding Kafka Topics and Partitions</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> kafka </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[qt开发遇到的各种坑]]></title>
      <url>https://disinuo.me/2018/05/23/2018-5-23-QTCreatorProcessEndForcefully/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我本科毕设是使用 <em>qt框架</em> 和 <em>QTCreator</em> 作为IDE进行项目开发，过程中遇到了很多很迷的bug或者遇到的问题在这边记录一下。<br><a id="more"></a></p>
<h3 id="BUG-1-程序异常退出的因素"><a href="#BUG-1-程序异常退出的因素" class="headerlink" title="BUG_1: 程序异常退出的因素"></a>BUG_1: 程序异常退出的因素</h3><p>程序在编译构建的时候没有报错，但是运行时控制台就会突然输出<br>【程序异常结束-The process was ended forcefully.】，然后程序就挂了。<br>在经过google以及自己的摸索后，总结了几个会导致报这个错误的原因，如下。</p>
<ul>
<li>直接使用空指针</li>
<li>直接使用没实例化的指针</li>
<li>除以0</li>
<li>数组越界</li>
<li>delete空指针</li>
</ul>
<p>反正就是记得把代码写的健壮性高一点吧，上面这些问题控制台都不输出具体的bug信息真的让人很蛋疼，一句【程序异常结束】就把我们打发了。。。orz<br>PS：debug模式可能是我不太会用吗反正也没定位到具体bug。。。如果有成功使用debug的小伙伴欢迎评论补充！~~</p>
<hr>
<h2 id="BUG-2-error-symbol-s-not-found-for-architecture-x86-64"><a href="#BUG-2-error-symbol-s-not-found-for-architecture-x86-64" class="headerlink" title="BUG_2: error: symbol(s) not found for architecture x86_64"></a>BUG_2: error: symbol(s) not found for architecture x86_64</h2><p>这个也是特别头疼的一个报错。。。可能存在的问题如下。</p>
<ul>
<li>环境配置的qt版本与代码使用的qt版本不兼容</li>
<li>slots如果在head里声明了而在cpp里没定义</li>
</ul>
<h2 id="如何绑定带参数的slot"><a href="#如何绑定带参数的slot" class="headerlink" title="如何绑定带参数的slot"></a>如何绑定带参数的slot</h2><p>下面这段代码要给一个button数组里的每个button都绑定同一个slot，但是传入的参数不同<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">media_ImageBtns = <span class="keyword">new</span> QPushButton*[MEDIA_MAX_NUM];</span><br><span class="line"><span class="comment">//使用一个QSignalMapper作为媒介</span></span><br><span class="line">QSignalMapper *signalMapper = <span class="keyword">new</span> QSignalMapper(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MEDIA_MAX_NUM;i++)&#123;</span><br><span class="line">    media_ImageBtns[i] = <span class="keyword">new</span> QPushButton(tr(<span class="string">"Button"</span>),<span class="keyword">this</span>);</span><br><span class="line">    media_ImageBtns[i]-&gt;setEnabled(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//下面这行代码的'map()'是qt自带的方法，</span></span><br><span class="line">    <span class="comment">//大致意思就是将每个button的“点击”信号，绑定给signalMapper的map()槽</span></span><br><span class="line">    connect( media_ImageBtns[i], SIGNAL(clicked()), signalMapper, SLOT(<span class="built_in">map</span>()));</span><br><span class="line">    <span class="comment">//大意是将每个button与一个参数绑定，并将这些绑定好的组存在mapper里</span></span><br><span class="line">    signalMapper-&gt;setMapping(media_ImageBtns[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将mapper与你自定义的带参数的slot绑定，</span></span><br><span class="line">  <span class="comment">//并且指定将刚刚与每个button对应的参数一一传递给你的自定义槽函数</span></span><br><span class="line">  connect(signalMapper, SIGNAL(mapped(<span class="keyword">int</span>)), <span class="keyword">this</span>, SLOT(your_slot(<span class="keyword">int</span>)));</span><br></pre></td></tr></table></figure></p>
<p>所以其实这个signalMapper就是一个中介啦~ 帮忙暂存并中转一下数据而已<br>哦记得要引用头文件 <code>#include &lt;QSignalMapper&gt;</code>~</p>
<hr>
<p>参考资料<br><a href="http://bbs.itheima.com/thread-330670-1-1.html" target="_blank" rel="noopener">Qt鼠标右键创建菜单</a><br><a href="https://blog.csdn.net/imred/article/details/72940365" target="_blank" rel="noopener">Qt使用connect函数时向slot传递参数</a></p>
]]></content>
      
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> qt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[近日杂谈]]></title>
      <url>https://disinuo.me/2018/04/21/2018-4-21-summary/</url>
      <content type="html"><![CDATA[<p>考上清华研究生、参加#一年读完柯林斯#、又一次半马228、拍毕业照、开了网易云电台练习口语~</p>
<a id="more"></a>
<h3 id="考研有了好结果"><a href="#考研有了好结果" class="headerlink" title="考研有了好结果"></a>考研有了好结果</h3><p>努力总算没有白费~</p>
<ul>
<li>2.4  出初试成绩</li>
<li>3.9  清华大学网站公布2018年研究生录取线。</li>
<li>3.13 清华大学软件学院公布复试名单，排名4/15</li>
<li>3.15 参加复试，上午笔试，下午面试。</li>
<li>3.18 体检。</li>
<li>3.21 收到清华大学软件学院email复试通过的通知。（电子邮件）</li>
<li>4.2  清华大学软件学院公布拟录取名单，排名2/12</li>
</ul>
<h3 id="一年读完柯林斯"><a href="#一年读完柯林斯" class="headerlink" title="一年读完柯林斯"></a>一年读完柯林斯</h3><p>柯林斯是一本英文词典嘛~这个活动就是每天读10页，用时200天把它读完。<br>知道这个活动是之前考研复习的时候知道了唐静老师，这个课程他是负责人之一，当时就想着考研完我也要报名。于是便在3.9开始了每天读词典的活动~<br>有人说读词典有什么用，确实我也不指望自己词汇量能猛增多少，我只是觉得，我好像从来没这样耐心的读过一本词典，就把它当做一本书看就好了啊~经常会看到各种有趣的用法，哪怕只是些我们很熟悉的单词组成的，比如：come clean about是坦白承认 ​​​​，bridge the gap是消除隔阂，bite the bullet渡过难关 等等。这些点滴的收获足以构成我参加这个课程的理由了~。并且我也想体验一下一件事坚持一年是什么样的感觉。<br>现在已经打卡40天啦~慢慢变成了习惯真的是很幸福了</p>
<h3 id="4-20拍毕业照"><a href="#4-20拍毕业照" class="headerlink" title="4.20拍毕业照"></a>4.20拍毕业照</h3><p>穿起了学士服，不知不觉就要毕业了呢，大学四年真的是过得飞快啊<br><img src="/image/2018-4-21-summary/me.jpg" alt="毕业照"></p>
<h3 id="再跑半马，遗憾没pb"><a href="#再跑半马，遗憾没pb" class="headerlink" title="再跑半马，遗憾没pb"></a>再跑半马，遗憾没pb</h3><p>开始跑马到现在断断续续也有两年了～首马是16年的扬马，可能是第一次有一股虎劲儿吧那次一直是我的PB，211<br>今天本来想pb的，但是大概4km的时候就开始岔气，走了一段，后来又时不时的岔气，我就意识到无缘pb了<br>有时候坚持与否真的就是一念之间。<br>第一次岔气后我就想，不然等会等收容车来接我算了，好了一点之后又想，不然在关门之前跑完吧～起码完赛<br>之后到了一个补给站拿了海绵之后仿佛满血复活，又想，不行，还是尽力跑吧！～</p>
<p>大概13km遇到了230的官兔，准备跟着他们跑了，后来还超过了他们哈哈<br>总之这次由于时不时的岔气我就几乎每个补给站都停下吃吃喝喝😌补给站的香蕉真好吃</p>
<p>最终2:28:40完赛，按照今天跑的状态来看还算不错了，但按照最开始想pb的野心来看远没有达到目标。<br>所以事实证明跑马前不好好训练，pb只能成为幻想🙃</p>
<p>另外，仙马虽然不是很大规模的赛事，但是我对主办方整体的印象是真的非常好！～<br>包括整体的组织很有秩序，取包的时候很顺利，给把【存包车号】印在号码簿上这个小细节点赞～沿途的补给站也超级多～完赛包里有能量棒😁<br>以及今天天气简直太适合跑步！！全程多云！非常舒服！</p>
<h3 id="在网易云开了个电台"><a href="#在网易云开了个电台" class="headerlink" title="在网易云开了个电台"></a>在网易云开了个电台</h3><p>叫这个☞<a href="http://music.163.com/#/djradio?id=526854581" target="_blank" rel="noopener">dsn的英语经典台词练习</a><br>欢迎各位订阅~欢迎点赞、提建议、点评我的发音 等等各种<br>现在出了4期，每周三更新~<br>开这个电台是为了练习一下自己的口语，不然学的一直是哑巴口语，然后记录下自己的成长过程（希望可以有成长。。。）<br>内容一般就是某些影视作品里我比较喜欢的片段的台词朗读，或者说叫重新演绎？我一般会模仿演员的口气和语调~<br>现有的4期分别是《真爱至上》、《楚门的世界》、《老友记》和一首诗《When you’re old》<br>为了练口语顺道找到好素材我现在在每天跟读老友记哈哈~有的时候真的能学到好多日常用语，比如可以用”This is a ‘Dear Diary ‘ moment”表示开心激动的心情~</p>
<h3 id="好好做毕设"><a href="#好好做毕设" class="headerlink" title="好好做毕设"></a>好好做毕设</h3><p>最近在学图像处理之类的东西，要开始写论文了！毕设好好搞~</p>
<h3 id="passion！"><a href="#passion！" class="headerlink" title="passion！"></a>passion！</h3><p>前几天一个passion老狗突然问我要不要上周年庆的OG秀！！这把我激动的啊！！！没想到毕业之前还能再上台跳个舞！！而且今年的周年庆宣传片炸的不行！除了上台跳舞之外我也能看现场了！！！超开心！！<br>搬到鼓楼之后就进入养老模式的我，很感谢passion还记得我^ ^~</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最近差不多就发生了这些~<br>在确定了要去清华读研了之后，欣喜之外，也是有压力的。平时空余时间要多多学习专业知识啊！<br>希望自己可以顺利毕业然后未来继续努力~~！</p>
<p>PS：弱弱的说一句，以后争取月更博客</p>
]]></content>
      
        
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[考研复习资料推荐]]></title>
      <url>https://disinuo.me/2018/01/07/2018-1-7-PQExam_referenceRecommendation/</url>
      <content type="html"><![CDATA[<p>首先声明，复习资料适用程度本就因人而异，本篇是我的使用经验和感受~各位酌情参考。<br>以及，本人是2018届考研党。</p>
<a id="more"></a>
<h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><h4 id="李永乐复习全书-660题-历年真题解析"><a href="#李永乐复习全书-660题-历年真题解析" class="headerlink" title="李永乐复习全书+660题+历年真题解析"></a>李永乐复习全书+660题+历年真题解析</h4><p>我买的是全套，包括分阶段习题，但觉得那本难度过高，只做了一章。<br>复习全书还是很全面的，推荐。<br>660题就是一本题册啦~可以刷一遍，第二遍再刷自己的错题。</p>
<p>不过我听了张宇的课觉得他讲得很好，但没时间看宇哥的书和题册了，所以你们也可以问问看用过张宇的书的学长姐质量如何～</p>
<p>然后真题也一定要吃透，可以多刷几遍，我10～16年的大概刷了4遍吧，当然后来只是刷错题</p>
<h3 id="‌英语"><a href="#‌英语" class="headerlink" title="‌英语"></a>‌英语</h3><h4 id="真题！可以买黄皮书系列的真题。解析比较详细。"><a href="#真题！可以买黄皮书系列的真题。解析比较详细。" class="headerlink" title="真题！可以买黄皮书系列的真题。解析比较详细。"></a>真题！可以买黄皮书系列的真题。解析比较详细。</h4><h4 id="作文我买的是王江涛的。"><a href="#作文我买的是王江涛的。" class="headerlink" title="作文我买的是王江涛的。"></a>作文我买的是王江涛的。</h4><p>英语吃透真题就够了，可以多做几次，摸透出题思路，不需要做模拟题。<br>很多英语考研名师都说模拟题一般质量会比真题差很多，所以除非你时间特别多，不然只做真题就可以啦。<br>首刷近10年的，时间够再刷近20年的。<br>我买了黄皮书系列的阅读150篇，就做了一点，后期就一直在做真题了。</p>
<p>作文讲道理王江涛那本还是挺好的，反正很多人都在用，但我莫名背不进去，所以你们也可以再考察考察。。。</p>
<h3 id="‌政治"><a href="#‌政治" class="headerlink" title="‌政治"></a>‌政治</h3><h4 id="肖秀荣精讲精练-肖秀荣1000题-肖四肖八-徐涛背诵笔记-徐涛小黄书"><a href="#肖秀荣精讲精练-肖秀荣1000题-肖四肖八-徐涛背诵笔记-徐涛小黄书" class="headerlink" title="肖秀荣精讲精练+肖秀荣1000题+肖四肖八+徐涛背诵笔记+徐涛小黄书"></a>肖秀荣精讲精练+肖秀荣1000题+肖四肖八+徐涛背诵笔记+徐涛小黄书</h4><p>这些是我买了的，你们可以参考着看看。<br>买了精讲精练就不需要买大纲解析了，我之前刷知乎经验贴是说，精讲精练比大纲解析容易看进去，所以就买的这个。</p>
<p>1000题就如数学660一样，用来刷题的。如果你复习的早，这个1000题可以多刷几遍。<br>那你就可以第一遍用铅笔写，把错题标记出来，然后擦掉，就可以反复利用。<br>我是时间不够了，第一遍做了全册，第二遍只做了单选错题。</p>
<p>肖四肖八是到最后一两个月的时候才会出版的，模拟题以及预测的作用，基本人手一本的。<br>肖四的分析题，就是大题，是要背的，肖大大预测还是蛮准的。</p>
<p>徐涛背诵笔记，就相当于是重要知识点的整理，还会有一些逻辑上的梳理，我觉得帮助很大，强化阶段用的。</p>
<p>你可能会听说风中劲草，那个也是知识点整理，但是会比这个背诵笔记全很多，但你也懂越到后期知识点就会越浓缩，包含的东西少但也更重点。我后来是没时间看风中劲草了，不过要是在复习的前期阶段这本还是不错的。</p>
<p><strong>小黄书！强推！</strong> 预测分析题的，我今年就是背的它，每道大题都压中了至少一个小问。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>专业课就各学校各专业各不相同啦，在这就不啰嗦了。</p>
<p>祝愿大家都取得理想成绩 ^ ^~<br>也希望我可以通过初试啊啊啊！~~~</p>
]]></content>
      
        
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[写在考研初试后]]></title>
      <url>https://disinuo.me/2018/01/07/2018-1-7-PQExam_afterFirstTest/</url>
      <content type="html"><![CDATA[<p>这是一篇干货和感想夹杂的文章。。。<br><a id="more"></a></p>
<h3 id="起点"><a href="#起点" class="headerlink" title="起点"></a>起点</h3><p>在决定要考清华之后，自己也是心里一点底都没有，因为，清华北大，在我心目中，一直是 天呐 望尘莫及的地位。<br>然后二三月份，开始查有关的资讯，初步了解关于考研 关于清华软件工程研究生的各种信息。知道了考试的科目，4月份开始第一轮复习专业课。其实这第一轮复习的还是比较水的，主要是听网课，做做笔记什么的。没有结合做题，所以真正记住的知识点并没有多少。</p>
<h3 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h3><p>因为暑假要去华为实习，所以我才4月份先开始复习一波的。</p>
<p>说到实习，好多人都不懂我为啥考研暑假还要去实习，要知道暑假可是复习考研的大好时光啊。<br>确实，但是我主要是因为当时不懂这些套路，另外也真的是想本科出去实习一次，才有了这样的安排。</p>
<p>虽然损失了暑期复习的时间，但是！真正坚定我考研的决心的也正是这次实习经历。<br>实习分到了一个不太对口的部门，然后我就在用自己的技能做一些辅助工作的工具，没怎么涉及业务。</p>
<p>所以有点无聊吧，学到的东西也不多，只能说是稍稍学到了一点职场经验。</p>
<p>然后对于一些看起来很高大上的部门，云计算啊机器学习啊之类的，又是想去但又完全没学过，没有相关知识，也就只能止于想想。<br>所以，我觉得，本科还只是学一些专业的基础一点的知识，要通过读研再在某个更专一点的方向多学一学，先把自己提升提升再迈入职场吧。</p>
<p>相比较损失的复习时间，我觉得树立起的坚定目标和因此催生的强大动力更加珍贵。</p>
<p>实习是6-8月，所以真正复习时间是9月-12.22，不到4个月<br>也制定了计划，一共4轮，差不多一个月一轮。总体节奏还算在自己的控制下，只不过中间确实心态崩过好多次，每科都让我崩过。。。</p>
<h3 id="数学复习"><a href="#数学复习" class="headerlink" title="数学复习"></a>数学复习</h3><p>数学资料买的是李永乐全套，那本知识点还是很全的，不过题册真的是偏难，跟往年真题比起来，做的就很虐。【虽然今年考试好像真的比往年难。手动doge脸】好多次做一上午数学从图书馆走出来感觉整个人都懵懵的。。。<br>9月做完了李永乐复习全书，挺多地方都没理解透的其实。因为概率论有的地方实在不理解，大二学的时候也没太学明白，就去听了张宇的概率论的课，帮助很大。我就想要不干脆微积分也听一听。就两倍速用几天时间把微积分的课听了一遍哈哈哈。查缺补漏吧~</p>
<p>也确实学到了一些更好的做题思路，比如伽马函数真的是6的不行，从此不再惧怕最后一道大题。<br>宇哥也经常励志一把，是因为他的【保证2点到6点的充足睡眠，就拼这一段时间能怎么样呢，我不是现在还活的好好的】我也开始照做。</p>
<p>也许好多人会抨击这种作息吧，但我觉得对我受用，我11月后半个月和12月上旬差不多是这个作息。因为我平时就睡得少，所以白天精神状态还可以。得补充一句，确实每个人都不一样，要在实践中检验和发展真理啊哈哈哈，不能教条，熬夜后白天困得要死的小伙伴就不建议这样了，还是保证充足高质量睡眠才是王道。</p>
<hr>
<h3 id="英语复习"><a href="#英语复习" class="headerlink" title="英语复习"></a>英语复习</h3><p>英语吧，我一直觉得我基础不算好，一轮二轮复习也有点忽略它了，主要背单词来着。然后做真题阅读完型错的非常惨烈，又心态爆炸。好在11月的时候 特别幸运遇到了章晋林老师。小林子讲阅读是真的好，选项定位、出题思路分析、做题技巧总结，人还特别可爱哈哈哈。真的有种茅塞顿开的感觉～然后我的阅读就从原来迷离状态半蒙半猜做题，变成了大部分题目可以精准定位，20道基本可以稳定在错5个以内，就是差不多一篇错一个【对于我来说真的算少了。。。】，要知道我原本每篇错两三个都是常事。</p>
<p>翻译我从来没管过，在知乎看经验贴说唐静老师讲的不错，就去听了听，也是帮助很大，以前都不知道翻译有这么多讲究。</p>
<p>作文主要就是12月背了14篇小作文模板，大作文背了几个套路的句子，掌握了一下三段式的结构。</p>
<hr>
<h3 id="政治复习"><a href="#政治复习" class="headerlink" title="政治复习"></a>政治复习</h3><p>政治，10月才开始列入我的复习计划。应该跟大家一样吧，这是一门从零开始的学科。<br>买了肖老精讲精练和1000题。每天上午看一上午。</p>
<p>一开始的马哲就把我虐的死死的。<br>啥？必然和自由是啥？？必然是什么玩意；华佗对症下药跟矛盾有什么关系？？？整个人都不太好orz<br>然后战友说可以去听听腿姐、徐涛的课，尤其马原会很有助于理解的。<br>然后我就开始了入坑这两个老师的征程哈哈哈~<br>腿姐语言通俗易懂，例子很生活很贴切。<br>涛哥很重整体逻辑的把控，一些经典口头禅也是可爱的不行：你看看你看看；这个选项你不选你想干什么。</p>
<p>在这两位老师的课的伴随下，学政治变成了每天很开心的事情，以及腿姐推荐的【将改革进行到底】，后来每天吃饭看，简直就是高级的知识点梳理视频嘛哈哈哈，而且让我对党和习大大的理解也更深刻了一点，看得贼燃～</p>
<hr>
<h3 id="专业课复习"><a href="#专业课复习" class="headerlink" title="专业课复习"></a>专业课复习</h3><p>专业课是复习的最没有章法的了，没有真题【能找到的都是回忆版】，没有系统的教材。于是我主要是听清华的学堂在线的网课，搭配课后练习题，把错题整理出来。【数据结构看严蔚敏的那本书】。以及在github找到了os课对应的一个仓库，里面好多练习题哈哈哈。</p>
<p>在某宝买的所谓清华考研复习资料也没什么含金量，基本都是网上可以找到的资料，而且还有很多答案都错了，导致我后来根本不敢用它了。</p>
<hr>
<h3 id="冲刺阶段"><a href="#冲刺阶段" class="headerlink" title="冲刺阶段"></a>冲刺阶段</h3><p>12月进入冲刺阶段了，政治资料乖乖的肖四肖八，时政小册，徐涛小黄书都买了。哦还用了腿姐冲刺宝典。</p>
<p>肖四肖八不用多说了，必买。</p>
<p>徐涛小黄书是真的靠谱，大题我主要是背的小黄书，然后参考肖四大题的出题资料、出题角度、答题思路，用小黄书的知识点答出来。</p>
<p>今年小黄书压中率也非常可观，涛哥说他也是喜忧参半，忧是因为感觉要被出题组盯上了哈哈哈<br>另外说实话时政小册子用处不大，内容太多了，小黄书里有重点的精简版时政，看这个就够了。<br>具体复习过程就说到这吧。</p>
<hr>
<h3 id="考前准备"><a href="#考前准备" class="headerlink" title="考前准备"></a>考前准备</h3><p>考前10天左右开始调整作息☞0.00-6.00。<br>但其实考前一周，有点失眠，要1点左右才能睡着，4、5点又醒了。<br>也许是压力大？但我心理上感觉其实还好哎，可能是生理上本能的紧张导致的吧。</p>
<p>12.13考场安排出来，开始 <strong>订酒店</strong>。<br>官网说的是12.14公布，还好我12.13，凌晨0.10多的时候出于好奇去看了一下，已经公布了！然后去订宾馆发现好多家都满了！我的妈你们都怎么知道是13号公布的！还好我看了一下，然后订了一家。刚爬上床要睡，结果发来短信说房满预定失败了。<br>吓得我赶紧又爬下来换了一家，短信说早上8.30之前会通知有没有订成功，这我就不敢睡了呀，就边复习边等，终于早上7点收到了预定成功的短信～！</p>
<p>考前一天中午出发去宾馆的，在第五十中学考。下午去看考场时学生还没放学不让进，不过好在学校比较小，只有三个教学楼，就在门口看了下位置图和考场安排就回去了。</p>
<h3 id="考中"><a href="#考中" class="headerlink" title="考中"></a>考中</h3><p>第一天的两科考的还算可以，而且背的满脑子的政治和作文终于可以暂时放在一边了。<br>而且午休时间真的短，我两天中午都是吃的面包，睡一觉醒来喝个咖啡再看看下午科目找找状态。所以真的真的不要想上午考完的科目了！没时间想。</p>
<p>第二天是炸裂的一天。两门都是时间不太够，考完心态崩崩崩<br>考完数学走回酒店的一路都整个人很郁闷，在想刚刚那道题怎么怎么样是不是就对了，另一道题有没有注意到怎么怎么样，是不是做错了。<br>然后意识到不能这样了！下午还有150分呢！<br>努力的，深呼吸，调整自己，进入备战专业课的状态。</p>
<p>因为有3科，要把每科主要知识点串一遍，我自己的盲点过一遍，以及还要退房，时间很紧张，没有午睡，直接喝了杯咖啡就开始肝了。</p>
<p>专业课考的也是一言难尽，有几个知识点我复习的时候没怎么关注，考到的时候脑袋嗡的一下，短暂的几秒钟闪过了自己要二战的想法，然后极力克制自己别想那些没用的赶紧把会的题目做出来。<br>旁边的人做题比我快，翻卷声也给我很大压力。</p>
<p>最后，每个人一个密封袋，要自己把题册和答题纸封起来交上去。</p>
<p>结束。</p>
<p>对了考试的时候最好戴个非电子表，虽然考场有钟，但是可能挂在后面啊！回头看很不方便！尤其你要是坐在第一排的话。。。不要问我是怎么知道的。。。orz<br>好在第二天的监考老师允许我的电子表带进去了，看时间方便了许多</p>
<h3 id="emmm碎碎念"><a href="#emmm碎碎念" class="headerlink" title="emmm碎碎念"></a>emmm碎碎念</h3><p>我在第一天考完的时候，意识到，整个考场30几人吧都是考清华，这个考点肯定有几个考场都是报考清华的【没敢去确认】，全国又有这么多城市，每个城市都有这么多考场的人跟我竞争，最后只要，10几个人，我得是南京唯一一个“晋级”的才有希望吧。。。想到这我就很绝望orz，又觉得如果我真的真的过了初试，哪怕只过初试，我也算是非常厉害了吧～！</p>
<hr>
<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>总体来说，我觉得考研的复习阶段，比高考累、比高考难。其实主要是因为没有大部队，不像高考前，老师、学校带着你复习，模考，还有那么多同学一起，相互激励共同奋斗着。。</p>
<p>而考研，更像是一场孤军奋战，我只有一个初中朋友，时不时的会交流下感想、进度，在心态崩的时候互相鼓励鼓励；一个学姐，会不时的给我分享分享经验什么的；以及有个考研的室友～但因为报考学校不一样，交流也不多。</p>
<p>所以，考研是一个集耐力、心态、学习能力、计划能力于一体的过程。</p>
<p>不管结果如何，坚持下来了的我们，走进了考场，并完整的参加完了所有考试的我们，已经很棒了！<br>希望初试有个好成绩，好好准备复试。</p>
<hr>
<p><strong>我很满足，我经历了人生中也许是最大型的两场考试——高考、考研；</strong></p>
<p><strong>我很幸运，考研一路遇到了腿姐、涛哥、宇哥、小林子、静静、肖老，这些好老师;</strong></p>
<p><strong>感谢在学习到了知识之余也学到了人生经验。</strong></p>
<p><strong>这趟旅途，不亏！～</strong></p>
<hr>
<ul>
<li>初稿 - 2017.12.26</li>
<li>完善 - 2018.1.7</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 考研 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[主机A给已知IP地址的主机B发送ip报文的过程]]></title>
      <url>https://disinuo.me/2017/07/31/2017-7-31-IP/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近一直在看网络的书，有的地方看得有点乱，这里总结一下两个主机之间发送数据包的过程。<br>可能内容会有小错误，欢迎在下面留言指出~<br>我之后学的更深入了也可能会来完善这篇~<br><a id="more"></a></p>
<h3 id="过程如下"><a href="#过程如下" class="headerlink" title="过程如下"></a>过程如下</h3><p>  1.封装好了有源ip、目标ip、报文内容的ip报文。交由而二层后要知道目的mac地址，所以下面是确定目的mac地址的过程~</p>
<p>  2.主机A先将主机B的ip跟自己的网络掩码相<code>与</code>，判断是否在同一网段</p>
<hr>
<blockquote>
<p><strong>3.a. 如果在同一网段：</strong><br>    1.主机A检查自己的ARP缓存有没有主机B的mac地址，没有的话就发一个ARP请求并把结果添加到ARP缓存里<br>    2.将B的mac地址以【目的mac】添加到mac帧头部。<br>    3.发送~Over</p>
</blockquote>
<hr>
<p><strong>3.b. 如果不在同一网段：</strong><br>    1.主机A检查自己的ARP缓存有没有默认网关的mac地址，没有的话就发一个ARP请求并把结果添加到ARP缓存里。<br>    (不在一个网段的话，就发给默认网关，默认网关再进一步分发~)<br>    2.将默认网关的mac地址以【目的mac】添加到mac帧头部。<br>    3.发送给默认网关<br>    4.默认网关接收到之后，查看【目的ip】，对照自己的路由表判断是否能直接交付</p>
<blockquote>
<p><strong>5.a. 如果能直接交付(就是B与默认网关的某个端口处于同一个网段)：</strong><br>      1.默认网关就查arp缓存(没有的话就发arp请求)，然后把B的mac地址以【目的mac】添加到mac帧头部。<br>      2.发送~Over</p>
</blockquote>
<blockquote>
<p><strong>5.b. 如果不能直接交付(还要再交给别的路由器)</strong><br>      1.默认网关通过路由表判断把此报文从哪个端口转发出去<br>      2.通过arp缓存查询该端口对应的路由器的mac地址(这个地方不是很确定。。)，并把它以【目的mac】添加到mac帧头部。<br>      3.如果一直不是直接交付就循环5b，否则就执行 5a 那步~最终发送到B</p>
</blockquote>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>抓住7月的尾巴发篇博客哈哈 ^ ^ ~</p>
]]></content>
      
        
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android：AsyncTask用法]]></title>
      <url>https://disinuo.me/2017/06/13/2017-06-13-android_asyncTask/</url>
      <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>AsyncTask是什么？—异步任务，听起来是用来执行一些比较耗时的操作的。<br>首先要知道Android的两个概念：主线程(又叫UI线程)和后台线程</p>
<ul>
<li>主线程：是一个Android程序开始运行时默认启动的线程，主要用来显示界面，跟用户交互</li>
<li>后台线程：除了主线程以外的线程，加载数据等</li>
</ul>
<p>所以，为了让用户体验好一点，为了程序能快速响应用户的操作，稍微耗时点的工作最好都不要放在主线程里啦~那我们要自己创线程吗？并不需要，Android给我们封装了一个类~就是这个 <strong>AsyncTask</strong> 啦~<br><a id="more"></a></p>
<h3 id="AsyncTask4个主要方法"><a href="#AsyncTask4个主要方法" class="headerlink" title="AsyncTask4个主要方法"></a>AsyncTask4个主要方法</h3><p>因为AsyncTask是抽象类，必须要继承、重写关键方法才能用<br>他们都是回调函数，就是我们负责实现就好，Android负责调用</p>
<ul>
<li>onPreExecute</li>
<li>doInBackground</li>
<li>onProgressUpdate</li>
<li>onPostExecute</li>
</ul>
<p>看名字就能猜出来个大概意思了，只有<code>onProgressUpdate</code>不大好理解，现在逐一解释一下</p>
<h4 id="onPreExecute"><a href="#onPreExecute" class="headerlink" title="onPreExecute"></a>onPreExecute</h4><p>这个是最先执行的方法，是在主线程执行的，一般进行一些初始的配置</p>
<h4 id="doInBackground-Params…"><a href="#doInBackground-Params…" class="headerlink" title="doInBackground(Params…)"></a>doInBackground(Params…)</h4><p>第二个执行的方法，是在后台线程执行的（也是主线程的子线程），用来做耗时操作的主要部分~</p>
<h4 id="onProgressUpdate-Progress…"><a href="#onProgressUpdate-Progress…" class="headerlink" title="onProgressUpdate(Progress…)"></a>onProgressUpdate(Progress…)</h4><p>这个是给用户反馈进度条用的~，我们可以在<code>doInBackground</code>里随时调用AsyncTask的函数<code>publishProgress</code>,<code>publishProgress</code>函数的内部会调用<code>onProgressUpdate</code>~等下举个例子就清楚啦</p>
<h4 id="onPostExecute-Result"><a href="#onPostExecute-Result" class="headerlink" title="onPostExecute(Result)"></a>onPostExecute(Result)</h4><p>在doInBackground执行 <strong>结束</strong> 之后执行，它的参数Result是<code>doInbackground</code>的返回值</p>
<blockquote>
<p>注意：除了doInBackground方法，另外3个都是在主线程执行的~</p>
</blockquote>
<h3 id="例子来啦"><a href="#例子来啦" class="headerlink" title="例子来啦"></a>例子来啦</h3><p>这个源于stackoverflow上一个大神给的例子~ 是一个模拟下载，显示进度百分数的过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskExample</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> TextView _percentField;</span><br><span class="line">    <span class="keyword">protected</span> InitTask _initTask;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        _initTask = <span class="keyword">new</span> InitTask();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这样就可以启动这个task啦</span></span><br><span class="line">        _initTask.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View rootView = inflater.inflate(R.layout.fragment_main, container, <span class="keyword">false</span>);</span><br><span class="line">        _percentField = (TextView)rootView.findViewById(R.id.percent_field);</span><br><span class="line">        <span class="keyword">return</span> rootView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    解释一下这里的3个参数，这是我们在继承AsyncTask时指定的三个泛型参数，</span></span><br><span class="line"><span class="comment">    分别是上面提到的三个回调方法所用的参数</span></span><br><span class="line"><span class="comment">    1. Params 在执行AsyncTask时需要传入的参数，即doInBackground的参数</span></span><br><span class="line"><span class="comment">    2. Progress 后台任务执行时，在界面上显示当前的进度的类型，即onProgressUpdate的参数</span></span><br><span class="line"><span class="comment">    3. Result 当任务执行完毕后，返回结果的类型，即onPostExecute的参数和doInBackground的返回值类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                    publishProgress(i);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Log.i(<span class="string">"makemachine"</span>, e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"COMPLETE!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.i(<span class="string">"makemachine"</span>, <span class="string">"onPreExecute()"</span>);</span><br><span class="line">            <span class="keyword">super</span>.onPreExecute();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onProgressUpdate(values);</span><br><span class="line">            Log.i(<span class="string">"makemachine"</span>, <span class="string">"onProgressUpdate(): "</span> + String.valueOf(values[<span class="number">0</span>]));</span><br><span class="line">            _percentField.setText((values[<span class="number">0</span>] * <span class="number">2</span>) + <span class="string">"%"</span>);</span><br><span class="line">            _percentField.setTextSize(values[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onPostExecute(result);</span><br><span class="line">            Log.i(<span class="string">"makemachine"</span>, <span class="string">"onPostExecute(): "</span> + result);</span><br><span class="line">            _percentField.setText(result);</span><br><span class="line">            _percentField.setTextColor(<span class="number">0xFF69adea</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是AysncTask的基本用法啦~</p>
<hr>
<p>参考<br><a href="https://classroom.udacity.com/courses/ud853/lessons/1469948762/concepts/15305685680923" target="_blank" rel="noopener">Udacity课程</a><br><a href="https://stackoverflow.com/questions/6450275/android-how-to-work-with-asynctasks-progressdialog" target="_blank" rel="noopener">StackOverflow</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/11711405" target="_blank" rel="noopener"> 郭霖:Android AsyncTask完全解析，带你从源码的角度彻底理解</a><br><a href="https://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="noopener">Android开发文档</a><br><a href="http://code.oneapm.com/android/2015/06/02/android1/" target="_blank" rel="noopener">Android开发者：你真的会用AsyncTask吗</a></p>
]]></content>
      
        
        <tags>
            
            <tag> android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java：Array(数组)和ArrayList的区别]]></title>
      <url>https://disinuo.me/2017/05/31/2017-05-31-array_arrayList/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在java中，ArrayList其实是内部封装了一个数组来放数据的。那我就想他们两个究竟有哪些区别呢<br>这篇博客主要以<a href="http://javahungry.blogspot.com/2015/03/difference-between-array-and-arraylist-in-java-example.html" target="_blank" rel="noopener">8 Difference Between Array And ArrayList In Java With Example</a>为基准~，有的地方加了自己的理解<br><a id="more"></a></p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="是否可改变size"><a href="#是否可改变size" class="headerlink" title="是否可改变size"></a>是否可改变size</h4><ul>
<li>数组不能改变size</li>
<li>ArrayList的size是动态的</li>
<li>原理：不是说ArrayList里也是一个数组嘛，那它怎么实现的动态size呢~看下源码（省略部分细节）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的【elementData】就是那个放数据的数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个方法的作用是 【size不够的话就扩容】</span></span><br><span class="line">    ensureExplicitCapacity(size + <span class="number">1</span>);  </span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要的最小容量比当前的实际容量大--&gt;去扩容！</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//扩容到原来的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//扩容完还是不够，那干脆你要多少我就扩到多少</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//处理溢出的情况</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">//复制elementData</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>所以其实每次调用ArrayList的add方法的时候它都默默的做着这些工作</li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul>
<li>自动扩容：ArrayList的自动扩容会降低性能。因为扩容时是使用了临时变量实现复制的</li>
<li>它俩的add()、get()的复杂度一样，（数组的add指的就是通过序号赋值啦）</li>
</ul>
<h4 id="元素类型"><a href="#元素类型" class="headerlink" title="元素类型"></a>元素类型</h4><ul>
<li>数组的元素类型可以是对象，也可以是基本类型</li>
<li>ArrayList的元素类型不能是基本类型<br>比如你 <strong>不能</strong> 这样初始化一个ArrayList<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="keyword">int</span>&gt; list=<span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>&gt;();<span class="comment">//会报错的！</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>那你可能会问，我可以这样写呀<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>看起来你是加的基本类型int，但其实JVM会把它解析成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));</span><br></pre></td></tr></table></figure></p>
<h4 id="迭代访问"><a href="#迭代访问" class="headerlink" title="迭代访问"></a>迭代访问</h4><ul>
<li><p>ArrayList可以创建迭代器Iterator，并且这个迭代器是Fail Fast的（这个翻译过来感觉怪怪的）。<br>什么是Fail Fast呢，就是：创建了某个ArrayList的迭代器，在这个迭代器迭代的过程中，如果这个ArrayList的长度被修改了(包括add、remove，使用的不是迭代器的方法)，会立刻(Fast)抛出异常(Fail)。（update一个元素不会抛异常，亲测）<br>一个简单例子~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">filterMinus</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">  Iterator&lt;Integer&gt; itr=list.iterator();</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (itr.hasNext())&#123;</span><br><span class="line">    <span class="keyword">int</span> x=itr.next();</span><br><span class="line">    System.out.println(x);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        list.remove(i);</span><br><span class="line">        <span class="comment">// itr.remove(); 把上面那行注掉用这行的，就不会抛异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>好像有点跑偏了，对 <a href="http://javahungry.blogspot.com/2014/04/fail-fast-iterator-vs-fail-safe-iterator-difference-with-example-in-java.html" target="_blank" rel="noopener">Fail Fast 感兴趣的话可以戳这里</a></p>
</li>
</ul>
<h4 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h4><ul>
<li>一个数组里的元素都是同一个类型的。因为创建数组的时候要声明类型嘛~</li>
<li>一个ArrayList的元素可以是不同类型</li>
<li>因为ArrayList在声明的时候可以不规定类型，其实可以理解为声明了一个<code>ArrayList&lt;Object&gt;的list</code>，这样看来的话也可以<code>Object[] array</code>声明一个数组~所以其实没什么区别啦</li>
</ul>
<h4 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h4><ul>
<li>数组：length属性</li>
<li>ArrayList：size()方法</li>
<li>本来我之前一直记混他俩获取长度的方式。现在终于明白为什么了。<ul>
<li>数组的长度不可改变，所以是一个public final的成员变量，反正大家都不可以改，直接public就好</li>
<li>ArrayList的长度是动态变化的，类内部可读可写，类外部仅可读，所以要把它封装成private的，外界通过get方法得到，也就是size()方法</li>
<li>自己的理解，不对的话欢迎指出！~^ ^</li>
</ul>
</li>
</ul>
<h4 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h4><ul>
<li>数组：直接通过序号赋值。  eg：array[0]=3.1;</li>
<li>ArrayList：通过add方法。eg：list.add(0,3.1);</li>
</ul>
<h4 id="多维"><a href="#多维" class="headerlink" title="多维"></a>多维</h4><p>原文作者说数组支持多维，ArrayList不可以。我不赞成这一点，不过这里还是写一下。比如下面这代码妥妥跑成功了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&gt; list=<span class="keyword">new</span> ArrayList&lt;List&gt;();</span><br><span class="line">List row1=<span class="keyword">new</span> ArrayList();</span><br><span class="line">row1.add(<span class="number">3</span>);</span><br><span class="line">row1.add(<span class="string">"hello"</span>);</span><br><span class="line">row1.add(-<span class="number">8.8</span>);</span><br><span class="line">row1.add(<span class="string">'a'</span>);</span><br><span class="line">list.add(row1);</span><br><span class="line">List row2=<span class="keyword">new</span> ArrayList();</span><br><span class="line">row2.add(<span class="number">88</span>);</span><br><span class="line">row2.add(<span class="number">666</span>);</span><br><span class="line">row2.add(<span class="string">"world"</span>);</span><br><span class="line">list.add(row2);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">//  输出</span></span><br><span class="line"><span class="comment">// [[3, hello, -8.8, a], [88, 666, world]]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>所以其实，我理解的ArrayList就是对Array的一个封装，提供了很多我们常用的方法（添加、删除一个元素等），减少了我们的使用负担（不必须初始化时决定大小、类型，自动扩容）</li>
</ul>
<hr>
<p>参考<br><a href="http://javahungry.blogspot.com/2015/03/difference-between-array-and-arraylist-in-java-example.html" target="_blank" rel="noopener">8 Difference Between Array And ArrayList In Java With Example</a><br><a href="http://javahungry.blogspot.com/2014/04/fail-fast-iterator-vs-fail-safe-iterator-difference-with-example-in-java.html" target="_blank" rel="noopener">Fail Fast Vs Fail Safe Iterator In Java : Java Developer Interview Questions</a><br><a href="http://www.java67.com/2012/12/difference-between-array-vs-arraylist-java.html" target="_blank" rel="noopener">Difference between Array vs ArrayList in Java</a></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android：ArrayAdapter工作原理【含源码分析】]]></title>
      <url>https://disinuo.me/2017/05/25/2017-05-27-android-adapter/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Adapter是个什么呢？~<br>它就相当于是MVC架构里的controller，负责数据和视图直接的联系。<br>而叫做<code>Adapter</code>也是因为应用了设计模式【适配器模式】的思想。它提供一个接口，使用者只管把数据丢给它，它负责将数据展示到指定的视图里<br>接下来就看看它的基本应用和原理~~~</p>
<h3 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h3><p>举个要展示一个数组的例子~<br><a id="more"></a></p>
<h4 id="Activity创建Adapter并set给view"><a href="#Activity创建Adapter并set给view" class="headerlink" title="Activity创建Adapter并set给view"></a>Activity创建Adapter并set给view</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String[] data = &#123;</span><br><span class="line">    <span class="string">"Mon 6/23 - Sunny - 31/17"</span>,</span><br><span class="line">    <span class="string">"Tue 6/24 - Foggy - 21/8"</span>,</span><br><span class="line">    <span class="string">"Wed 6/25 - Cloudy - 22/17"</span>,</span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; weekForecast = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(data));</span><br><span class="line">ArrayAdapter adapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(</span><br><span class="line">                        getActivity(), <span class="comment">// 上下文</span></span><br><span class="line">                        R.layout.list_item_forecast, <span class="comment">// layout的ID</span></span><br><span class="line">                        R.id.list_item_forecast_textview, <span class="comment">// 想把单项数据放在里面的view的ID</span></span><br><span class="line">                        weekForecast);<span class="comment">//数据</span></span><br><span class="line">  <span class="comment">//展示数据的界面</span></span><br><span class="line">ListView listView = (ListView) rootView.findViewById(R.id.listview_forecast);</span><br><span class="line">listView.setAdapter(adapter);</span><br></pre></td></tr></table></figure>
<h4 id="看看xml们长什么样"><a href="#看看xml们长什么样" class="headerlink" title="看看xml们长什么样"></a>看看xml们长什么样</h4><blockquote>
<p>单项数据的layout，文件名是 list_item_forecast</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:minHeight</span>=<span class="string">"?android:attr/listPreferredItemHeight"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"center_vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/list_item_forecast_textview"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>ListView的layout</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">"@+id/listview_forecast"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       /&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="/image/2017-05-27-android-adapter/screenshot.png" alt></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>ArrayAdapter有一个<code>getView()</code>方法，在setAdapter之后调用这个方法可以获得逐项数据对应的view。（这个方法是隐式调用的）</li>
<li>要明确两个概念：<ul>
<li>一个屏幕能放下的item数量</li>
<li>item总量（就是一共有多少条数据）</li>
</ul>
</li>
<li>一般item总量远大于一个屏幕能放下的数量~<h4 id="getView-源码"><a href="#getView-源码" class="headerlink" title="getView()源码"></a>getView()源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, @Nullable View convertView,</span></span></span><br><span class="line"><span class="function"><span class="params">            @NonNull ViewGroup parent)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createViewFromResource(mInflater, position, convertView, parent, mResource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="meta">@NonNull</span> <span class="function">View <span class="title">createViewFromResource</span><span class="params">(@NonNull LayoutInflater inflater, <span class="keyword">int</span> position,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable View convertView, @NonNull ViewGroup parent, <span class="keyword">int</span> resource)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> View view;</span><br><span class="line">  <span class="keyword">final</span> TextView text;</span><br><span class="line"><span class="comment">// 敲黑板啦！！--------下面是重点~~</span></span><br><span class="line"><span class="comment">// 这个convertView呢，就相当于是屏幕上的item</span></span><br><span class="line"><span class="comment">// 这里进行if判断，null代表这个convertView还没有被创建</span></span><br><span class="line">  <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//所以新创建一个view</span></span><br><span class="line">      view = inflater.inflate(resource, parent, <span class="keyword">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不是null表示这个convertView被创建过啦，</span></span><br><span class="line">      <span class="comment">// 所以接下来要做的就是更新这个view里面的数据</span></span><br><span class="line">      view = convertView;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这个position是数据数组的序号，就是这个view要展示第position个数据~</span></span><br><span class="line">  <span class="keyword">final</span> T item = getItem(position);</span><br><span class="line">  text = (TextView) view;<span class="comment">//</span></span><br><span class="line">  text.setText(item.toString());   </span><br><span class="line">  <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="原理解析–实例"><a href="#原理解析–实例" class="headerlink" title="原理解析–实例"></a>原理解析–实例</h4><p>可能上面说的不大明白，这里再举个例子说明一下。</p>
<ul>
<li>假如有100条数据，但是设备的一个屏幕只能显示下7条。</li>
<li>那一开始<code>getView</code>会被调用7次，生成7个view。<br>而这7次调用的<code>if(converView==null)</code>都是等于<code>true</code>的</li>
<li>当用户滚动屏幕，导致最上面的item滑出屏幕，第8个item进入屏幕时，<code>getView</code>会被调用一次。<br>而这次<code>if</code>判断等于false，因为7个view都已经存在了，所以这次getView的工作是把第8条数据的值赋值给第一个view并返回</li>
</ul>
<blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实本来想找一下源码哪里调用了getView的。。但是失败了。。。看来看源码的功力还要修炼很久啊~~</p>
</blockquote>
<hr>
<p>参考<br><a href="https://developer.android.com/guide/components/activities.html" target="_blank" rel="noopener">Android官方文档</a><br><a href="https://github.com/codepath/android_guides/wiki/Using-an-ArrayAdapter-with-ListView" target="_blank" rel="noopener">Using-an-ArrayAdapter-with-ListView</a><br><a href="https://www.youtube.com/watch?v=2lcoB5-PCCw" target="_blank" rel="noopener">Udacity课程</a><br><a href="https://stackoverflow.com/questions/10160475/when-getview-in-arrayadapter-is-called" target="_blank" rel="noopener">StackOverFlow–when-getview-in-arrayadapter-is-called</a></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring的controller接口参数类型List<MyClass>报错]]></title>
      <url>https://disinuo.me/2017/05/25/2017-05-25-spring_controller_interface_List/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在做一个j2ee项目，原本设计成前端发送HTTP请求时提交的数据是几个基本类型和一个数组，这个数组类型是一个自定义的类，长下面这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuestInputVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userRealName;</span><br><span class="line">    <span class="keyword">private</span> String idCard;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> vipId=-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//省略了每个成员变量的Get、Set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="报错场景复原"><a href="#报错场景复原" class="headerlink" title="报错场景复原"></a>报错场景复原</h3><a id="more"></a>
<h4 id="Controller的接口"><a href="#Controller的接口" class="headerlink" title="Controller的接口"></a>Controller的接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/liveIn"</span>,</span><br><span class="line">method = RequestMethod.POST,</span><br><span class="line">produces = <span class="string">"text/html;charset=UTF-8"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">liveIn</span><span class="params">(<span class="keyword">int</span> bookBillId,<span class="keyword">int</span> roomId,List&lt;GuestInputVO&gt; guests)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="前端请求数据格式"><a href="#前端请求数据格式" class="headerlink" title="前端请求数据格式"></a>前端请求数据格式</h4><p>前端的http请求我用的是JQuery，发送的数据格式如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里是假数据~</span></span><br><span class="line"><span class="keyword">var</span> guests=[&#123;</span><br><span class="line">    userRealName:<span class="string">"Andy"</span>,</span><br><span class="line">    idCard:<span class="string">"111222200033338888"</span>,</span><br><span class="line">    vipId:<span class="string">""</span></span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    userRealName:<span class="string">"Miley"</span>,</span><br><span class="line">    idCard:<span class="string">"111222198810096666"</span>,</span><br><span class="line">    vipId:<span class="string">"1000008"</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">var</span> data=&#123;</span><br><span class="line">        roomId: $(<span class="string">'#roomId'</span>).val(),</span><br><span class="line">        bookBillId: $(<span class="string">'#bookBillId'</span>).val(),</span><br><span class="line">        guests: guests</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h4><p>然后！后端就炸了。把JQuery请求回调函数的返回Error放在html里可以看到下面的错误提示<br><img src="/image/2017-05-25-spring_controller_interface_List/list_error.png" alt></p>
<h3 id="抢救一：封装到bean里"><a href="#抢救一：封装到bean里" class="headerlink" title="抢救一：封装到bean里"></a>抢救一：封装到bean里</h3><p>Google了好多，终于有一个办法让我看到了一点曙光</p>
<h4 id="创建一个类，让List作为它的成员变量"><a href="#创建一个类，让List作为它的成员变量" class="headerlink" title="创建一个类，让List作为它的成员变量"></a>创建一个类，让List作为它的成员变量</h4><p>说白了就是再封装一层，于是我有创建了一个类<code>LiveInVO</code>,结构如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveInVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bookBillId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> roomId;</span><br><span class="line">    <span class="keyword">private</span> List&lt;GuestInputVO&gt; guests;</span><br><span class="line">    <span class="comment">//还是省略了每个成员变量的Get、Set方法~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="更新Controller接口"><a href="#更新Controller接口" class="headerlink" title="更新Controller接口"></a>更新Controller接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略@注释啦</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">liveIn</span><span class="params">(LiveInVO liveInVO)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>前端那边是不用改的~这次我重启项目，发现！<strong>报错内容换了</strong>！！！<br>哈哈哈不知道你们会不会懂这种奇怪的兴奋点~<br>因为起码说明刚刚那个bug解决了呀~<br>于是来看看这次是什么报错<br><img src="/image/2017-05-25-spring_controller_interface_List/bean_error.png" alt><br>为啥会这么stupid的去访问 <code>guests[0][idCard]</code>？？？<br>应该访问<code>guests[0].idCard</code>才对呀！！<br>想了半天 大概是spring不认识我封装在LiveInVO里面的数组类型GuestVO吧，把它当成了数组？毕竟我这里是嵌套了两层自定义类（个人猜测，欢迎讨论~~ ^ ^）</p>
<h3 id="抢救二"><a href="#抢救二" class="headerlink" title="抢救二"></a>抢救二</h3><p>那现在List问题解决了，但是两层嵌套的自定义类不可行，那我就把第二层换成Map吧~这样前端代码还是不用改</p>
<h4 id="自定义类型LiveInVO更新"><a href="#自定义类型LiveInVO更新" class="headerlink" title="自定义类型LiveInVO更新"></a>自定义类型LiveInVO更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveInVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bookBillId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> roomId;</span><br><span class="line">    <span class="comment">// 注意这里改成了Map~~~</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Map&lt;String,Object&gt;&gt; guests;</span><br><span class="line">    <span class="comment">//还是省略了每个成员变量的Get、Set方法~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="相应的修改"><a href="#相应的修改" class="headerlink" title="相应的修改"></a>相应的修改</h4><p>然后可以在后端的某个地方把map转换成可读性更高的自定义类型<code>GuestInputVO</code>~<br>觉得放在Controller或service里都不够好，为了低耦合高内聚，<br>我是把转换方法做成了一个<code>GuestInputVO</code>新的构造器。代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GuestInputVO</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userRealName=(String)map.get(<span class="string">"userRealName"</span>);</span><br><span class="line">    <span class="keyword">this</span>.idCard=(String)map.get(<span class="string">"idCard"</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vipId=Integer.parseInt((String)map.get(<span class="string">"vipId"</span>));</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">this</span>.vipId=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加完这个构造器 如果没有显示的写一个无参构造器要记得加一个！不然spring没法构造bean啦~~~</span></span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>搞定啦~<br>或者有小伙伴有其他解决办法欢迎讨论~~~邮件或下面评论都可以哦^ ^</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> j2ee </tag>
            
            <tag> spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DOM Parser]]></title>
      <url>https://disinuo.me/2017/04/13/2017-04-14-DOM-parser/</url>
      <content type="html"><![CDATA[<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>Document Object Model</p>
<h3 id="DOM-Parser"><a href="#DOM-Parser" class="headerlink" title="DOM Parser"></a>DOM Parser</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>将 XML 整个作为类似树结构的方式读入内存中以便操作及解析<br><a id="more"></a></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>实现 W3C 标准，有多种编程语言支持这种解析方式，并且这种方法本身操作上简单快捷，十分易于初学者掌握。</li>
<li>其处理方式是将 XML 整个作为类似树结构的方式读入内存中以便操作及解析，因此支持应用程序对 XML 数据的内容和结构进行修改</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>但是同时由于其需要在处理开始时将整个 XML 文件读入到内存中去进行分析，因此其在解析大数据量的 XML 文件时会遇到类似于内存泄露以及程序崩溃的风险，请对这点多加注意。</li>
</ul>
<h4 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h4><ul>
<li>小型 XML 文件解析</li>
<li>需要修改XML文档的内容/结构/顺序</li>
<li>需要多次遍历文档【用DOM就不需要每次都重新扫描文档】</li>
<li>需要将几个xml文档合并</li>
<li>需要操作文档的内容</li>
</ul>
<h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><p><img src="/image/2017-04-14-DOM-parser/DOM-process.png" alt></p>
<h5 id="（一）创建DOM-parser"><a href="#（一）创建DOM-parser" class="headerlink" title="（一）创建DOM parser"></a>（一）创建DOM parser</h5><ol>
<li>创建工厂实例</li>
<li>设置工厂的参数<br><img src="/image/2017-04-14-DOM-parser/factory-options.png" alt></li>
<li>通过工厂创建Builder实例</li>
</ol>
<h5 id="（二）Parser读取xml"><a href="#（二）Parser读取xml" class="headerlink" title="（二）Parser读取xml"></a>（二）Parser读取xml</h5><h5 id="（三）异常处理"><a href="#（三）异常处理" class="headerlink" title="（三）异常处理"></a>（三）异常处理</h5><p>在这个过程中可能会产生如下几种异常</p>
<ul>
<li>javax.xml.parsers.ParserConfigurationException:</li>
<li>java.lang.IllegalArgumentException:</li>
<li>java.io.IOException: xml文件打不开</li>
<li>org.xml.sax.SAXException:xml有错误</li>
</ul>
<h5 id="（四）生成DOM树"><a href="#（四）生成DOM树" class="headerlink" title="（四）生成DOM树"></a>（四）生成DOM树</h5><h5 id="（五）调用方可以对DOM树对象操作-增删改查"><a href="#（五）调用方可以对DOM树对象操作-增删改查" class="headerlink" title="（五）调用方可以对DOM树对象操作(增删改查)"></a>（五）调用方可以对DOM树对象操作(增删改查)</h5><h5 id="（六）最后，调用方把xml输出"><a href="#（六）最后，调用方把xml输出" class="headerlink" title="（六）最后，调用方把xml输出"></a>（六）最后，调用方把xml输出</h5><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1。创建parser</span></span><br><span class="line">DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">DocumentBuilder builder = factory.newDocumentBuilder();</span><br><span class="line"><span class="comment">// 2+3+4.读取xml，处理error，生成DOM树</span></span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"dom.xml"</span>);</span><br><span class="line">Document dom=builder.parse(f);</span><br><span class="line"><span class="comment">// 5 对DOM树操作</span></span><br><span class="line">NodeList contacts = dom.getElementsByTagName(<span class="string">"Contact"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contacts.getLength(); i++) &#123;</span><br><span class="line">     Element contact = (Element) contacts.item(i);</span><br><span class="line">     System.out.println(contact.getNodeValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一切皆Node"><a href="#一切皆Node" class="headerlink" title="一切皆Node"></a>一切皆Node</h4><h5 id="4种Node"><a href="#4种Node" class="headerlink" title="4种Node"></a>4种Node</h5><p>Document(root)、Element、Attribute、Text</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p>  <img src="/image/2017-04-14-DOM-parser/node-example.png" alt></p>
<h5 id="是组合模式的应用"><a href="#是组合模式的应用" class="headerlink" title="是组合模式的应用"></a>是组合模式的应用</h5><p>  <img src="/image/2017-04-14-DOM-parser/composite-pattern.png" alt></p>
<h5 id="提供接口"><a href="#提供接口" class="headerlink" title="提供接口"></a>提供接口</h5><pre><code>1. public String getNodeName()
- public String getNodeValue()throws DOMException
- public void setNodeValue(String nodeValue)throws DOMException
- public short getNodeType()
- public Node getParentNode()
- public NodeList getChildNodes()
- public Node getFirstChild()
- public Node getLastChild()
- public Node getPreviousSibling()
- public Node getNextSibling()
- public NamedNodeMap getAttributes()
- public Document getOwnerDocument()
</code></pre><p><img src="/image/2017-04-14-DOM-parser/interface.png" alt></p>
<hr>
<p>参考<br><a href="https://www.cs.bgu.ac.il/~dwss111/wiki.files/XML/xm341v13_dom.pdf" target="_blank" rel="noopener">xm341v13_dom.pdf</a><br><a href="https://www.ibm.com/developerworks/cn/xml/dm-1208gub/" target="_blank" rel="noopener">ibm:java处理三种xml主流技术介绍</a></p>
]]></content>
      
        
        <tags>
            
            <tag> SOA </tag>
            
            <tag> DOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记第一次淋雨的马拉松]]></title>
      <url>https://disinuo.me/2017/03/19/2017-03-19-marathon_wuxi/</url>
      <content type="html"><![CDATA[<p>算下来这是第4次参加马拉松了~都是半马。<br>这次成绩02:19:41~【感觉成绩一直没有第一次跑好的也就只有我了吧。。。】<br><a id="more"></a><br>这次是第一次参加无锡马拉松~昨天上午跟跑团的学长姐一起坐了一个多小时的绿皮火车来到无锡，先吃了顿大餐之后去领装备。<br>讲道理我真的没见过这么多人领物的，听说这次马拉松外地报名的人有2万。而且还要刷身份证进去~还会识别人脸和身份证是不是一致的。。~超严格</p>
<p>参赛包里给了一个 我们叫丑娃娃的。。。小娃娃。。<br><img src="/image/2017-03-19-marathon_wuxi/doll.png" alt="丑娃娃"><br>大概是考虑到会下雨吧~这次组委会搞了防水的参赛包，但是我就想问一下为啥！要做这么大。。。orz不过除了大以外都挺好的~<br>因为要穿跑团的队服就没有穿官方给的小粉T恤啦~这种无袖的t恤我大概还要在瘦个两三圈才敢穿~。。。</p>
<p>今早5：30起的床【我们住的地方离起点超近的都要起这么早。。。真的不敢想象住得远的小伙伴们要几点起】<br>好啦直接说重点<br>今天一开始是多云嘛~还挺开心的~跑着也不热。然后我开始阶段配速一直控制在6分15左右~出乎意料的稳定哈哈哈<br>这次跑的不累，在10km喝了第一次水~<br>之后天就越来越阴。。。感觉大事不好。<br>我跑到14km的位置时开始下雨，雨越来越大，后来把眼镜拿在了手上。其实雨大到是小事，主要是风也很大，于是就很冷orz。。。<br>而且跑一跑雨和汗就混着要流进眼睛，还好戴了参赛包里给的手套~可以擦一擦~<br>然后。。。大概15、16km左右我的蓝牙耳机没电了。。。除了不能听歌以外，更重要的是听不到自己的配速和跑了多少公里了，就没办法及时调整什么的了嘛。不过那一段好像1km就有一个牌子，后来19-21km一直没看到牌子。。。我还以为一直在跑19。。。<br>然后最后200m的时候才知道要到终点了~讲道理我觉得自己的体力可以早一点冲刺的~哎还是怪自己没把耳机充好电，下次一定要长记性。<br>话说最后100m是江南大学田径场上的100m也是很神奇哈哈哈<br><img src="/image/2017-03-19-marathon_wuxi/route.png" alt="路线图~"><br>按照学长姐的说法我跑了这么多次半马该跑全马了，但是这配速还是有点虚orz起码半马要进2小时10分吧！进了我就去报全马~！<br>对了锡马完赛包里的吃的好评！菠萝包和黑米面包都好好吃~~~还有那个迷之造型的香蕉哈哈哈也是很厉害<br><img src="/image/2017-03-19-marathon_wuxi/banana.png" alt="神奇的香蕉"></p>
<p>对了~奖牌！<br><img src="/image/2017-03-19-marathon_wuxi/reward.png" alt="奖牌"></p>
]]></content>
      
        
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hibernate：Get vs Load -- 源码分析]]></title>
      <url>https://disinuo.me/2017/03/07/2017-03-08-hibernate_get_load/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>本文贴的源码都是删减版。。。~一些异常的判断、处理，都被省略掉了<br>只贴了主要的部分~</li>
<li>Hibernate版本  5.1.0<a id="more"></a>
</li>
</ul>
<h2 id="源码比较"><a href="#源码比较" class="headerlink" title="源码比较"></a>源码比较</h2><h3 id="SessionImpl类"><a href="#SessionImpl类" class="headerlink" title="SessionImpl类"></a>SessionImpl类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 848。被dao直接调用的方法</span></span><br><span class="line"><span class="comment">// ------load-------</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">load</span><span class="params">(Class&lt;T&gt; entityClass, Serializable id)</span> <span class="keyword">throws</span> HibernateException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.byId(entityClass).getReference(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">load</span><span class="params">(String entityName, Serializable id)</span> <span class="keyword">throws</span> HibernateException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.byId(entityName).getReference(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------get-------</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Class&lt;T&gt; entityClass, Serializable id)</span> <span class="keyword">throws</span> HibernateException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.byId(entityClass).load(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String entityName, Serializable id)</span> <span class="keyword">throws</span> HibernateException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.byId(entityName).load(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>load调用了getReference；get调用了load【感觉这方法名有点迷。。。<br>然后这两个方法做一些判断后，分别调用了<code>doReference</code>和<code>doLoad</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2398。load调用doGetReference</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">doGetReference</span><span class="params">(Serializable id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//实体id,实体名,LockOptions,session</span></span><br><span class="line">  LoadEvent event=<span class="keyword">new</span> LoadEvent(id, <span class="keyword">this</span>.entityPersister.getEntityName(), <span class="keyword">false</span>, SessionImpl.<span class="keyword">this</span>);</span><br><span class="line">  SessionImpl.<span class="keyword">this</span>.fireLoad(event, LoadEventListener.LOAD);<span class="comment">//触发事件的方式</span></span><br><span class="line">  <span class="keyword">return</span> event.getResult();</span><br><span class="line">&#125;</span><br><span class="line">------------</span><br><span class="line"><span class="comment">// 2446。get调用doLoad</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> T <span class="title">doLoad</span><span class="params">(Serializable id)</span> </span>&#123;</span><br><span class="line">   LoadEvent event = <span class="keyword">new</span> LoadEvent(id, <span class="keyword">this</span>.entityPersister.getEntityName(), <span class="keyword">false</span>, SessionImpl.<span class="keyword">this</span>);</span><br><span class="line">   SessionImpl.<span class="keyword">this</span>.fireLoad(event, LoadEventListener.GET);</span><br><span class="line">   <span class="keyword">return</span> event.getResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 调用同一个方法，只是LoadType不同。<br> 先看这个相同的方法<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 986。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fireLoad</span><span class="params">(LoadEvent event, LoadType loadType)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注意这里是获得【事件】类型为LOAD的监听器。事件类型和加载类型是不一样的概念！</span></span><br><span class="line">  <span class="comment">// 本文解析的get()方法和load()方法的事件类型都是LOAD，但加载类型不同</span></span><br><span class="line">  Iterator var3 = <span class="keyword">this</span>.listeners(EventType.LOAD).iterator();</span><br><span class="line">  <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">      LoadEventListener listener = (LoadEventListener)var3.next();</span><br><span class="line">      listener.onLoad(event, loadType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>比较LoadType的不同之处<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get 允许为null,不允许创建代理。</span></span><br><span class="line"><span class="comment">// LOAD 不允许为null,允许创建代理</span></span><br><span class="line">LoadEventListener.LoadType GET = (<span class="keyword">new</span> LoadEventListener.LoadType(<span class="string">"GET"</span>)).</span><br><span class="line">                                setAllowNulls(<span class="keyword">true</span>).</span><br><span class="line">                                setAllowProxyCreation(<span class="keyword">false</span>).</span><br><span class="line">                                setCheckDeleted(<span class="keyword">true</span>).</span><br><span class="line">                                setNakedEntityReturned(<span class="keyword">false</span>);</span><br><span class="line">LoadEventListener.LoadType LOAD = (<span class="keyword">new</span> LoadEventListener.LoadType(<span class="string">"LOAD"</span>)).</span><br><span class="line">                                setAllowNulls(<span class="keyword">false</span>).</span><br><span class="line">                                setAllowProxyCreation(<span class="keyword">true</span>).</span><br><span class="line">                                setCheckDeleted(<span class="keyword">true</span>).</span><br><span class="line">                                setNakedEntityReturned(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="DefaultLoadEventListener类"><a href="#DefaultLoadEventListener类" class="headerlink" title="DefaultLoadEventListener类"></a>DefaultLoadEventListener类</h3><p>get和load都调用这个onLoad，并且二者的LoadEvent一模一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 63。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(LoadEvent event, LoadType loadType)</span> <span class="keyword">throws</span> HibernateException </span>&#123;</span><br><span class="line">   EntityPersister persister = <span class="keyword">this</span>.getPersister(event);</span><br><span class="line">   <span class="keyword">this</span>.doOnLoad(persister, event, loadType);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 86。两者的persister,event都相同。只有loadType不同</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doOnLoad</span><span class="params">(EntityPersister persister, LoadEvent event, LoadType loadType)</span> </span>&#123;</span><br><span class="line"><span class="comment">//  entityKey相同</span></span><br><span class="line">   EntityKey e = event.getSession().generateEntityKey(event.getEntityId(), persister);</span><br><span class="line">   <span class="keyword">if</span>(loadType.isNakedEntityReturned()) &#123;<span class="comment">//-----情况1 两者都不是这种情况</span></span><br><span class="line">       event.setResult(<span class="keyword">this</span>.load(event, persister, e, loadType));</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>(event.getLockMode() == LockMode.NONE) &#123;<span class="comment">//-----情况2</span></span><br><span class="line">       event.setResult(<span class="keyword">this</span>.proxyOrLoad(event, persister, e, loadType));</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;<span class="comment">//------情况3</span></span><br><span class="line">       event.setResult(<span class="keyword">this</span>.lockAndLoad(event, persister, e, loadType, event.getSession()));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 因为LoadEvent的构造函数把LockMode设置成了<code>DEFAULT_LOCK_MODE</code>,<br> 而其类的内部又定义了 <code>DEFAULT_LOCK_MODE = LockMode.NONE;</code><br> 所以get和load都属于情况2</p>
<h4 id="分流get和load"><a href="#分流get和load" class="headerlink" title="分流get和load"></a>分流get和load</h4><p>proxyOrLoad方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  152。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">proxyOrLoad</span><span class="params">(LoadEvent event, EntityPersister persister, EntityKey keyToLoad, LoadType options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!persister.hasProxy()) &#123;</span><br><span class="line">    <span class="comment">//   hasProxy() Determine whether this entity supports dynamic proxies.</span></span><br><span class="line">    <span class="comment">// 不支持代理的话，就老实的去调用load</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.load(event, persister, keyToLoad, options);<span class="comment">//等下下面会提到这个方法</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 支持代理</span></span><br><span class="line">      PersistenceContext persistenceContext = event.getSession().getPersistenceContext();</span><br><span class="line">      Object proxy = persistenceContext.getProxy(keyToLoad);</span><br><span class="line">      <span class="comment">// 这句代码有点长。</span></span><br><span class="line">      <span class="comment">// 大概意思就是，通过上下文获得一个代理</span></span><br><span class="line">      <span class="comment">// 这个代理非空的话，则返回一个NarrowProxy</span></span><br><span class="line">      <span class="comment">// 这个代理为空的话-----如果允许创建代理--LOAD---就调用创建代理方法</span></span><br><span class="line">      <span class="comment">// ------------------不允许创建--GET---------再调用上面的load--&gt;doLoad</span></span><br><span class="line">      <span class="keyword">return</span> proxy != <span class="keyword">null</span>?</span><br><span class="line">      <span class="keyword">this</span>.returnNarrowedProxy(event, persister, keyToLoad, options, persistenceContext, proxy)</span><br><span class="line">      :(</span><br><span class="line">          options.isAllowProxyCreation()?</span><br><span class="line">          <span class="keyword">this</span>.createProxyIfNecessary(event, persister, keyToLoad, options, persistenceContext)</span><br><span class="line">          :<span class="keyword">this</span>.load(event, persister, keyToLoad, options)</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 187。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createProxyIfNecessary</span><span class="params">(LoadEvent event, EntityPersister persister, EntityKey keyToLoad, LoadType options, PersistenceContext persistenceContext)</span> </span>&#123;</span><br><span class="line">    Object existing = persistenceContext.getEntity(keyToLoad);</span><br><span class="line">    <span class="keyword">if</span>(existing != <span class="keyword">null</span>) &#123;<span class="comment">//上下文中有这个实体，则返回</span></span><br><span class="line">        <span class="keyword">return</span> existing;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有这个实体，则创建代理并返回。就是是假的实体！！！</span></span><br><span class="line">        Object proxy = persister.createProxy(event.getEntityId(), event.getSession());</span><br><span class="line">        persistenceContext.getBatchFetchQueue().addBatchLoadableEntityKey(keyToLoad);</span><br><span class="line">        persistenceContext.addProxy(keyToLoad, proxy);</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实实在在的加载数据"><a href="#实实在在的加载数据" class="headerlink" title="实实在在的加载数据"></a>实实在在的加载数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 132。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">load</span><span class="params">(LoadEvent event, EntityPersister persister, EntityKey keyToLoad, LoadType options)</span> </span>&#123;</span><br><span class="line">   Object entity = <span class="keyword">this</span>.doLoad(event, persister, keyToLoad, options);</span><br><span class="line">   <span class="keyword">return</span> entity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 239。session缓存--&gt;二级缓存--&gt;数据库</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">doLoad</span><span class="params">(LoadEvent event, EntityPersister persister, EntityKey keyToLoad, LoadType options)</span> </span>&#123;</span><br><span class="line">   Object entity = <span class="keyword">this</span>.loadFromSessionCache(event, keyToLoad, options);</span><br><span class="line">   <span class="keyword">if</span>(entity == REMOVED_ENTITY_MARKER) &#123;</span><br><span class="line">       LOG.debug(<span class="string">"Load request found matching entity in context, but it is scheduled for removal; returning null"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>(entity == INCONSISTENT_RTN_CLASS_MARKER) &#123;</span><br><span class="line">       LOG.debug(<span class="string">"Load request found matching entity in context, but the matched entity was of an inconsistent return type; returning null"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>(entity != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> entity;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       entity = <span class="keyword">this</span>.loadFromSecondLevelCache(event, persister, keyToLoad);</span><br><span class="line">       <span class="keyword">if</span>(entity != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//  省略。这里源代码在写日志~</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           entity = <span class="keyword">this</span>.loadFromDatasource(event, persister);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> entity;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，当访问load得到的对象的属性时，会访问数据库。——–所谓的延迟加载</p>
<h2 id="使用比较"><a href="#使用比较" class="headerlink" title="使用比较"></a>使用比较</h2><ul>
<li><p>load拿到的是假对象为什么还要用它？<br>举个例子~<br>就比如一个预订房间系统，用户每提交一个订单Order就应该包含一个房间Room<br>如果每次都像下面这样的话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Room room=session.get(Room.class,roomId);</span><br><span class="line">order.setRoom(room);</span><br></pre></td></tr></table></figure>
<p>就每次都要访问数据库，开销太大。<br>因为这里拿到room之后我们也不需要得到它的属性值，只是set给order，其实只需要一个id就够了<br>所以可以用load来加载实体~如果订单数量大的话差距会很明显的！~</p>
</li>
<li>听起来好像不错那我们为什么还要用get？(下面假设实体支持代理)<br>因为load不管三七二十一都会返回一个对象。<br>由于返回对象的时候不访问数据库，所以load返回的对象不能保证真的在数据库里。一旦我们访问对象的属性—访问数据库的时候，发现这个对象并不存在，就会抛异常，后知后觉。。。<br>而get，当需要加载的对象不存在时，会返回null，我们可以立即知道这个对象是否真的存在</li>
<li>所以 当确定对象存在的时候再用load<h2 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h2></li>
</ul>
<ol>
<li>绝大部分情况，get返回实体，load返回代理</li>
<li>当session缓存中有代理时，get会返回代理</li>
<li>当session缓存中没有代理、但有实体时，load返回实体</li>
<li>实体不支持代理时，get和load相当于是一样的</li>
</ol>
<hr>
<p>参考资料</p>
<p><a href="https://www.mkyong.com/hibernate/different-between-session-get-and-session-load/" target="_blank" rel="noopener">hibernate的get和load</a><br><a href="http://www.journaldev.com/3472/hibernate-session-get-vs-load-difference-with-examples" target="_blank" rel="noopener">Hibernate Session get() vs load() difference with examples</a><br><a href="http://1831651.blog.51cto.com/1821651/1225423" target="_blank" rel="noopener">Hibernate深入浅出（八）持久层操作——延迟加载（Lazy Loading）</a><br><a href="https://www.iflym.com/index.php/code/201112050001.html" target="_blank" rel="noopener">从源码上分析hibernate的load和get之间的区别</a><br><a href="https://www.dynatrace.com/blog/understanding-caching-in-hibernate-part-one-the-session-cache/" target="_blank" rel="noopener">Understanding Caching in Hibernate </a><br><a href="http://gmarwaha.blogspot.co.at/2007/01/hibernate-difference-between-sessions.html" target="_blank" rel="noopener">Hibernate - Difference between session’s get() and load()</a><br><a href="http://www.cnblogs.com/binjoo/articles/1621254.html" target="_blank" rel="noopener">hibernate的get和load区别</a></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> j2ee </tag>
            
            <tag> hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript之继承]]></title>
      <url>https://disinuo.me/2017/01/28/2017-01-28-javascript_extend/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说明一下，本文提到的‘类’，不是java、C里那种‘类’~<br>javascript里是没有类的概念的，只是为了方便表达~将一个包含构造器、原型的变量叫做‘类’。<br>javascript里的继承，跟java、C等比起来，看起来好像很随意。。。<br>因为javascript里的‘类’的构成，包含两部分嘛——–构造器和原型，<br>所以继承也包括两部分~原型继承和构造器继承，都得手动自己来~<br>所以其实也可以单独继承构造器或者原型。<br><a id="more"></a></p>
<h3 id="继承原理"><a href="#继承原理" class="headerlink" title="继承原理"></a>继承原理</h3><p>javascript的继承是基于原型链哒~<br>原型链两个相邻的原型，靠近顶端的是另一个的‘父类’或‘超类’。<br>比如有原型链如下</p>
<blockquote>
<p>A -&gt; B.prototype -&gt; Object.prototype -&gt;null</p>
</blockquote>
<p>B是A的父类~</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设有一个<code>书</code>的‘类’，下面是它的构造器和原型（构造器和原型不知道是啥的话可以看这里<a href="https://disinuo.me/2017/01/26/2017-01-26-javascript_prototype/">javascript 原型与构造器之‘原型’</a>，<a href="https://disinuo.me/2017/01/26/2017-01-26-javascript_constructor/">javascript 原型与构造器之构造器</a>）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Book=<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;;</span><br><span class="line">Book.prototype=&#123;</span><br><span class="line">    <span class="keyword">constructor</span>:Book,</span><br><span class="line">    getName:function () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后呢~有一个<code>小说</code>的’类’要继承<code>书</code>。然后看下面继承的两个步骤~</p>
<h3 id="继承Part1–构造器继承"><a href="#继承Part1–构造器继承" class="headerlink" title="继承Part1–构造器继承"></a>继承Part1–构造器继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Fiction = <span class="function"><span class="keyword">function</span> (<span class="params">name,author</span>) </span>&#123;</span><br><span class="line">    Book.call(<span class="keyword">this</span>,name); <span class="comment">//调用Book的构造器</span></span><br><span class="line">    <span class="keyword">this</span>.author=author;   <span class="comment">//在构造器里给Fiction添加了一个“作者”属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先解释一下<code>call</code>函数。<br>call是javascript里Function类型变量自带的函数，参数个数不定。<br>第一个参数是会作为该函数执行时的<code>this</code>。关于this可参考(javascript之this的绑定)[<a href="https://disinuo.me/2016/12/24/2016-12-24-javascript_this]">https://disinuo.me/2016/12/24/2016-12-24-javascript_this]</a><br>接下来的参数就都是调用call的函数本身的参数啦~<br>所以这里<code>Book.call(this,name)</code>是把Fiction的this传给Book，把name传给Book的构造器。</p>
<blockquote>
<p>为什么要这么费劲的把Fiction的this传给Book呢？直接<code>Book(name);</code>不行吗？</p>
</blockquote>
<p>不行哒~因为Book的构造器里是<code>this.name=name</code>，如果不传入Fiction的this，这句代码的this就是Book的this，就不会按照我们预想的给Fiction类创建name属性。所以要用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">call函数</a>或者<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">apply函数</a>调用父类构造器~</p>
<p>所以可以看到~只要在构造器里调用另一个’类’的构造器，就算是在构造器上继承了~<br>这个子类也就拥有了父类在构造器上创建的方法、属性。<br>比如接下来我们创建一个实例~<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blind_fiction=<span class="keyword">new</span> Fiction(<span class="string">'Harry Porter'</span>,<span class="string">'J.K.'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(blind_fiction.name);   <span class="comment">//Harry Porter</span></span><br><span class="line"><span class="built_in">console</span>.log(blind_fiction.author); <span class="comment">//J.K.</span></span><br><span class="line"><span class="built_in">console</span>.log(blind_fiction <span class="keyword">instanceof</span> Book); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>instanceof是用来判断一个变量是否是一个“类”的实例哒~<br>判断的原理是查找这个变量的原型链，只要在原型链里找到了这个“类”，就会返回true。<br>所以可见，虽然我们只是手动的进行了构造器继承，但js解释器会在子类的原型链里添加父类的原型~<br>原型链就这么串起来啦~<br>但这样还没有完全继承，这时候还不能通过子类的实例访问父类原型里的属性、方法，所以我们来看下一个part~</p>
<h3 id="继承Part2–原型继承"><a href="#继承Part2–原型继承" class="headerlink" title="继承Part2–原型继承"></a>继承Part2–原型继承</h3><p>继续上面的例子~<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fiction.prototype=<span class="built_in">Object</span>.create(Book.prototype);<span class="comment">//继承Book原型</span></span><br><span class="line">Fiction.prototype.constructor=Fiction;<span class="comment">//显示定义Fiction的构造器</span></span><br><span class="line">Fiction.prototype.getAuthor=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//给Fiction原型添加getAuthor方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.author;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Object.create方法的参数是一个原型~<br>明明一个类创建完，它的原型里会自动包含一个constructor属性，指向自己的构造器，那第二行为什么还要显示定义一下构造器呢？<br>因为第一行重新给Fiction的原型赋值了嘛~原来的原型就被覆盖了，这个新的原型就不包含constructor属性了，所以这里如果输出Fiction的构造器会输出Book的构造器（<code>console.log(Book.prototype.constructor);</code>）。<br>因为访问Fiction没有的属性，会继续沿着原型链向上找~于是就找到了Book的构造器~<br>那现在验证一下原型链的继承吧~<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(blind_fiction.getName());   <span class="comment">//Harry Porter</span></span><br><span class="line"><span class="built_in">console</span>.log(blind_fiction.getAuthor()); <span class="comment">//J.K.</span></span><br></pre></td></tr></table></figure></p>
<h3 id="class-extends语法糖"><a href="#class-extends语法糖" class="headerlink" title="class,extends语法糖"></a>class,extends语法糖</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>ECMAScript6 为了让熟悉java、C的开发人员用js用的更顺手，引入了一套新的关键字~<br>class,extends,constructor,super。下面举个例子~<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,age) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    getAge()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> animal=<span class="keyword">new</span> Animal(<span class="string">'Baby'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(animal.getName());  <span class="comment">//Baby</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.name);       <span class="comment">//Baby</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog=<span class="keyword">new</span> Dog(<span class="string">'dogge'</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog.name);      <span class="comment">//dogge</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.getAge());      <span class="comment">//8</span></span><br><span class="line"><span class="built_in">console</span>.log(dog <span class="keyword">instanceof</span> Animal); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul>
<li>class里面，constructor就是对应的构造器啦~</li>
<li>class里除constructor外的所有方法都是创建在原型里的。</li>
<li><p>关于class关键字的使用：声明和赋值。<br>上面例子里形如<code>class XXX{}</code>的就是声明。下面这种形如<code>var XXX=class{}</code>的是赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Animal =<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Dog =<span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,age) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    getAge()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里的<code>声明</code>，跟js普通的变量声明有一点不同，变量声明有<code>变量提升</code>现象~(参考 <a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html" target="_blank" rel="noopener">ben cherry的JavaScript Scoping and Hoisting</a>)<br>而class是没有的，所以如果父类的声明在子类之后是会报错的！~~</p>
</li>
</ul>
<p>本文涉及的源码可以<a href="https://github.com/disinuo/Demo_for_learningJS" target="_blank" rel="noopener">戳这里^ ^</a>（还包含javascript系列的其他部分的源码哦）<br>大年初一写博客的我绝对是真爱~哈哈哈</p>
<hr>
<p>参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">MDN 继承与原型链文档</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof" target="_blank" rel="noopener">MDN instanceof文档</a></p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript 原型与构造器之‘构造器’]]></title>
      <url>https://disinuo.me/2017/01/26/2017-01-26-javascript_constructor/</url>
      <content type="html"><![CDATA[<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>其实构造器就是方法，只是当你用<code>new</code>调用它的时候它就是构造器了（new的作用参见<a href="https://disinuo.me/2017/01/10/2017-01-10-javascript_new/">javascript关键字new</a>）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person=<span class="function"><span class="keyword">function</span> (<span class="params">name,age</span>)</span>&#123;<span class="comment">//这就是个Person的构造器</span></span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.hobbies=[<span class="string">'Drawing'</span>,<span class="string">'Music'</span>];</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype=&#123;<span class="comment">//这是Person的原型</span></span><br><span class="line">    <span class="keyword">constructor</span>:Person,</span><br><span class="line">    sex:'Male',</span><br><span class="line">    friends:['Lihua','Oliver'],</span><br><span class="line">    getName:function () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>原型不大清楚的可以参考这篇  <a href="https://disinuo.me/2017/01/26/2017-01-26-javascript_prototype/">javascript 原型与构造器之‘原型’</a> ^ ^~<br><a id="more"></a></p>
<h3 id="创建对象本身的属性"><a href="#创建对象本身的属性" class="headerlink" title="创建对象本身的属性"></a>创建对象本身的属性</h3><p>上面的构造器里形如<code>this.name=name</code>的代码，都是在给 <strong>对象自身</strong> 添加属性，<br>于是通过该构造器创建的 <strong>实例本身</strong> 也就拥有了相应的属性。<br>与原型的属性不同，原型的属性是实例共享的，而构造器创建的属性，是每个实例独自拥有的。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面的代码基于上面Person的构造器和原型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person(<span class="string">'Lily'</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person(<span class="string">'Amy'</span>,<span class="number">24</span>);</span><br><span class="line">person1.sex=<span class="string">'Female'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.sex);<span class="comment">//Female</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.sex);<span class="comment">//Male</span></span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">'Selena'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends);<span class="comment">//Lihua,Oliver,Selena</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends);<span class="comment">//Lihua,Oliver,Selena</span></span><br><span class="line"></span><br><span class="line">person1.friends=[<span class="string">'Lihua'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends);<span class="comment">//Lihua</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends);<span class="comment">//Lihua,Oliver,Selena</span></span><br><span class="line"></span><br><span class="line">person1.hobbies.push(<span class="string">'Movie'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.hobbies);<span class="comment">//Drawing,Music,Movie</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.hobbies);<span class="comment">//Drawing,Music</span></span><br></pre></td></tr></table></figure></p>
<p>比较两个push的不同~<br>(除这4行输出外不理解的话可以看下我的上一篇博客~)<a href="https://disinuo.me/2017/01/26/2017-01-26-javascript_prototype/">javascript 原型与构造器之‘原型’</a><br>person1.friends的push，对两个实例都产生了影响；<br>person1.hobbies的push仅对person1产生了影响。<br>因为friends是原型的属性，实例共享；而hobbies是实例的属性，每个实例都有自己独立的。</p>
<h3 id="避免实例间属性干扰"><a href="#避免实例间属性干扰" class="headerlink" title="避免实例间属性干扰"></a>避免实例间属性干扰</h3><p>所以~要解决，像代码中‘改变person1的friends时，无意中也把person2的friends改了’这种情况，<br>可以把该属性从原型中转移到构造器里~就好啦~</p>
<h3 id="原型-vs-构造器"><a href="#原型-vs-构造器" class="headerlink" title="原型 vs 构造器"></a>原型 vs 构造器</h3><p>下面这些结论都是我看书啊听课啊学到的+自己总结的~不是那么绝对~欢迎讨论~~</p>
<ol>
<li>实例独立的属性都放在构造器里：<br>相当于java里面类的成员变量。<br>为了避免上述‘friends’的类似情况。<br>但是又会有疑问，如果不是数组类型呢，比如String类型的name，<br>上一篇不是说赋值的时候解释器会自动在实例上创建属性吗。<br>确实，从实现的角度看确实不会产生实例间的干扰了。但是自动创建属性的话，实例和原型就都拥有了该属性，而原型的该属性就会永远被屏蔽，占着空间却没卵用的数据，会对性能造成影响的。</li>
<li>‘静态属性’放在原型里：<br>‘静态属性’是指基于同一个原型的实例们都一样的属性。<br>这种属性如果在构造器里，每个实例各自有一个，反而白占了很多空间</li>
<li>方法放在原型里：<br>这个跟上一条是一样的道理，就像java里面，类的方法一样，每个对象都是一样的呀~<br>也就没有每个实例都独自持有一份的必要啦。</li>
</ol>
<p>本文涉及的源码可以<a href="https://github.com/disinuo/Demo_for_learningJS" target="_blank" rel="noopener">戳这里^ ^</a>（还包含javascript系列的其他部分的源码哦）</p>
<hr>
<p>参考<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">MDN文档</a></p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript 原型与构造器之‘原型’]]></title>
      <url>https://disinuo.me/2017/01/26/2017-01-26-javascript_prototype/</url>
      <content type="html"><![CDATA[<h3 id="js独特的原型"><a href="#js独特的原型" class="headerlink" title="js独特的原型"></a>js独特的原型</h3><p>不同于C、Java等语言基于<code>类</code>，javascript是基于<code>原型</code>的。<br>原型本质也是对象。<br>每个对象都有原型（javascript中最基本的原型是Object.prototype）。<br>每个实例（当然，一定是个对象）都有一个原型，而这个原型作为一个对象，也有原型，从而形成了原型链。<br>原型链的顶端是null（Object.prototype的原型是null）。<br><a id="more"></a></p>
<h3 id="原型示例"><a href="#原型示例" class="headerlink" title="原型示例"></a>原型示例</h3><p>下面创建一个“类”Animal，以及Animal的原型。（这里“类”打了引号，因为它不是类，但又不知道怎么叫它了。。。）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Animal=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype=&#123;</span><br><span class="line">  name:<span class="string">'Dogge'</span>,</span><br><span class="line">  sleep:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"sleeping~"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见我们在Animal的原型上创建了一个属性<code>name</code>，一个方法<code>sleep</code>。</p>
<h3 id="原型链的形成"><a href="#原型链的形成" class="headerlink" title="原型链的形成"></a>原型链的形成</h3><p>接下来创建一个基于上面这个原型的实例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog=<span class="keyword">new</span> Animal();</span><br><span class="line"><span class="built_in">console</span>.log(dog.name);<span class="comment">//Dogge</span></span><br></pre></td></tr></table></figure></p>
<p>此时对象dog的原型链是 <strong>dog -&gt; Animal.prototype -&gt; Object.prototype -&gt; null</strong>。<br>这里说明一下，通常情况下原型链的顶端两个都是 Object.prototype -&gt; null，除非像下面这样这样创建<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="built_in">Object</span>.create(<span class="literal">null</span>); <span class="comment">//此时原型链是 a -&gt; null</span></span><br></pre></td></tr></table></figure></p>
<p><code>Object.create</code>方法是用来创建对象的，参数是该对象基于的原型。比如可以这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// a ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</span><br><span class="line"><span class="comment">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></span><br></pre></td></tr></table></figure></p>
<h3 id="实例与原型的关系"><a href="#实例与原型的关系" class="headerlink" title="实例与原型的关系"></a>实例与原型的关系</h3><p>原型是唯一，并且实例间共享的。<br>可以理解为，通过实例可以访问到原型的属性（这里的属性包含方法，下同），是因为实例持有原型的属性的<code>引用</code>。<br>所以如果一个实例修改了原型的属性，基于该原型的其它实例的该属性也会被修改。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">    sex:<span class="string">'Male'</span>,</span><br><span class="line">    friends:[<span class="string">'Lihua'</span>,<span class="string">'Oliver'</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person();</span><br><span class="line">person1.friends.push(<span class="string">'Selena'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends);<span class="comment">//Lihua,Oliver,Selena</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends);<span class="comment">//Lihua,Oliver,Selena</span></span><br></pre></td></tr></table></figure></p>
<p>这里，本来是想给person1增加朋友Selena，结果person2的朋友也变了。这就很尴尬了。<br>将在下一篇<a href="https://disinuo.me/2017/01/26/2017-01-26-javascript_constructor/">javascript 原型与构造器之构造器</a>的部分说怎么办~<br>在此之前，你可能也发现了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person1.sex=&apos;Female&apos;;</span><br><span class="line">console.log(person1.sex);//Female</span><br><span class="line">console.log(person2.sex);//Male</span><br></pre></td></tr></table></figure></p>
<p>改person1的性别，person2的没有变啊，这是怎么回事。<br>这就涉及到了javascript神奇的属性访问与创建的原则。</p>
<h3 id="属性的访问与创建机制"><a href="#属性的访问与创建机制" class="headerlink" title="属性的访问与创建机制"></a>属性的访问与创建机制</h3><ul>
<li>创建<br>跟java不一样，在java里，如果给对象一个不存在的属性<code>赋值</code>（注意！是 <strong>赋值</strong>），是会报错的。<br>而在javascript里这一点就显得很智能。。。解释器会帮你自动创建一个属性并赋值~</li>
<li>访问<br>那访问属性的时候呢，是先在对象本身上找，找不到就再到它的原型上去找，找不到再到原型的原型上去找，以此类推，直到找到该属性或到达原型链顶端为止（到顶端也没找到就返回undefined）。</li>
</ul>
<p>所以上面的代码<code>person1.sex=&#39;Female&#39;;</code>，由于person1对象本身没有属性sex，sex属性是它的原型的，所以解释器就自动帮person1创建了sex属性，并赋值为Female。<br>所以可以看到，这句代码并没有修改原型的sex属性，因而访问person2.sex就自然还是Male啦~<br>感兴趣的话可以加一句<code>console.log(person1);</code>，在浏览器控制台将对象展开，可以看到这样的结构<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person</span><br><span class="line">---sex: <span class="string">'Female'</span></span><br><span class="line">---__proto__:   <span class="comment">#这个就是原型属性</span></span><br><span class="line">------sex: <span class="string">'Male'</span></span><br></pre></td></tr></table></figure></p>
<p>所以当打印<code>person1.sex</code>的时候打印的是Female，是因为上面提到的访问机制，先找person1本身，找到了sex属性，于是就返回结果停止查找了（这个现象叫<code>属性屏蔽</code>）。<br>那现在再回头想一下，为什么<code>person1.friends.push(&#39;Selena&#39;)</code>的时候操作的就是原型的属性了呢，为什么解释器没有自动给person1创建一个friends属性呢。<br>因为，前面我强调了是<code>赋值</code>。push不叫赋值。<br>这里我是这样理解的（有不同见解欢迎提出~）：<br>对Array才能push，所以解释器一定要认得friends属性是一个Array。<br>而javascript自动创建属性需要你的初始化赋值，否则它创建的属性就是<code>undefined</code>。<br>所以<code>person1.friends.push(&#39;Selena&#39;)</code>时，是先在对象本身上找friends了的，发现是<code>undefined</code>，这就跟没有是一样的，于是才继续找原型的。<br>而且我还试了一下，把原型的friends属性删掉，重新执行<code>person1.friends.push(&#39;Selena&#39;)</code>，会报错<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot read property <span class="string">'push'</span> <span class="keyword">of</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></p>
<p>就是因为friends是undefined所以报错了嘛~<br>而如果接着上面的代码再加几行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person1.friends=[<span class="string">'Lihua'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends);<span class="comment">//Lihua</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends);<span class="comment">//Lihua,Oliver,Selena</span></span><br></pre></td></tr></table></figure></p>
<p>看~果然 <code>赋值</code>就会自动创建属性啦~</p>
<p>有点长了，<code>构造器</code>以及<code>原型和构造器比较</code>的部分放在下一篇吧 ^ ^~<br>本文涉及的源码可以<a href="https://github.com/disinuo/Demo_for_learningJS" target="_blank" rel="noopener">戳这里^ ^</a>（还包含javascript系列的其他部分的源码哦）</p>
<hr>
<p>参考<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">MDN文档</a></p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript迷之闭包]]></title>
      <url>https://disinuo.me/2017/01/23/2017-01-23-javascript_closure/</url>
      <content type="html"><![CDATA[<h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><p>2017-01-24 改了下‘封装私有变量’的代码；’闭包的概念’部分的文字表述；添加常见应用–‘模仿块级作用域’</p>
<h3 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h3><p>闭包，简单来说就是指那些能够访问另一函数作用域内变量的函数。<br>比如最基础的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name=<span class="string">'Shelly'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func=person();</span><br><span class="line">func(); <span class="comment">//Shelly</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>作为一个码惯了java的人，是不大能理解这里为什么函数person都执行完了，还能成功打印出’Shelly’的。<br>事实上，函数person返回的匿名函数，在这里就形成了一个闭包。<br>可以理解为，这个闭包的作用域链含有 包含这个闭包的函数的作用域，于是这个闭包就拥有包含它的函数的局部变量的引用。<br>比如这个例子里就是person的name的备份。<br>就是说，在函数执行结束后，若返回的是一个闭包，此函数的作用域和变量就不会销毁，<br>依旧可以通过它返回的闭包，来访问此函数的局部变量。</p>
<h3 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h3><ul>
<li><h4 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        result[i]=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funcs=createFunction();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;funcs.length;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(funcs[i]());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预想是输出0到9，结果却输出了10个10。。。</span></span><br><span class="line"><span class="comment">// 这是为什么呢。。。</span></span><br><span class="line"><span class="comment">// 可以这样理解</span></span><br><span class="line"><span class="comment">// 注意上述代码的4至6行的匿名函数 function () &#123;return i;&#125;</span></span><br><span class="line"><span class="comment">// 虽然循环了10次产生了10个这样的匿名函数，但是它们形成的是1个闭包</span></span><br><span class="line"><span class="comment">// 这1个闭包里只有1个i，所以result的每一项的函数返回的都是同一个东西~</span></span><br><span class="line"><span class="comment">// 这也就解释了为什么是10个相同的数字</span></span><br><span class="line"><span class="comment">// 那为什么这个数字是10呢</span></span><br><span class="line"><span class="comment">// 因为在for循环了10次之后，i最终被赋值成10而结束循环</span></span><br><span class="line"><span class="comment">// 所以当上述代码12行处调用函数输出i的时候，输出的就是最终的i的值啦~</span></span><br><span class="line"><span class="comment">// 我也是花了好长时间才明白的。。。不理解的话多找找资料~本文结尾的参考链接都是不错的资料~说不定哪句话就点醒你了呢^ ^</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 另外，可以将上述代码4至6行改成下面的样子以达到预想目标</span></span><br><span class="line">result[i]=<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(i);</span><br><span class="line"><span class="comment">// 这样改可以实现，是因为，</span></span><br><span class="line"><span class="comment">// 把原来的function()&#123;return i;&#125;外面</span></span><br><span class="line"><span class="comment">// 包了一个`立即执行`函数（就是在函数体后直接追加小括号，里面放要传的参数，该函数就会被立即执行）</span></span><br><span class="line"><span class="comment">// 由于函数传参是值拷贝传递的，而且是立即执行，所以i的每个值都复制传给了x</span></span><br><span class="line"><span class="comment">// 所以当后面分别调用func[i]输出的就是0到9啦~</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h4><p>来看一个例子~<br>一个生产<code>检查变量类型</code>函数的工厂</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isType</span>(<span class="params">type</span>)</span>&#123; <span class="comment">//这个就是工厂啦~</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj)===<span class="string">'[object '</span>+type+<span class="string">']'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> isString=isType(<span class="string">'String'</span>);<span class="comment">//检查是否是字符串的函数</span></span><br><span class="line"><span class="keyword">var</span> isNumber=isType(<span class="string">'Number'</span>);<span class="comment">//检查是否是Number的函数</span></span><br><span class="line"><span class="built_in">console</span>.log(isNumber(<span class="number">233</span>));   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(isNumber(<span class="string">'hhh'</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(isString(<span class="string">'hhh'</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 上述代码中，工厂的返回值就形成了一个闭包，所以isString、isNumber可以访问isType的局部变量type</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="封装私有变量"><a href="#封装私有变量" class="headerlink" title="封装私有变量"></a>封装私有变量</h4><p>可以用闭包来弥补一下javascript里没有private的遗憾~~</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name=<span class="string">'Lily'</span>;</span><br><span class="line">    <span class="keyword">var</span> age=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">this</span>.getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.addAge=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        age++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.getAge=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(func.name);     <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(func.getName());<span class="comment">//Lily</span></span><br><span class="line">func.addAge();</span><br><span class="line"><span class="built_in">console</span>.log(func.getAge()); <span class="comment">//21</span></span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h4><p>因为javascript没有块级作用域，就是像for循环啊、if else语句等这种，代码块里用到的变量在外面也可以使用。<br>这会带来一定程度的变量名污染，和一些奇怪的bug<br>不过好在可以使用闭包模仿出块级作用域~看下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p=<span class="number">0</span>;p&lt;<span class="number">5</span>;p++)&#123;</span><br><span class="line">&#125;<span class="comment">// 循环体外也可以读写变量p</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> m=<span class="number">0</span>;m&lt;<span class="number">5</span>;m++)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();<span class="comment">//将变量m封印在for里~</span></span><br><span class="line"><span class="built_in">console</span>.log(p);<span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(m);<span class="comment">//Error! m is not defined</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>闭包是一个神奇又强大的东西~<br>现在理解的还是不够深刻<br>继续学习~~~<br>欢迎指出错误~欢迎讨论~<br><a href="https://github.com/disinuo/Demo_for_learningJS" target="_blank" rel="noopener">想看源码可以戳这里^ ^</a>（还包含javascript系列的其他部分的源码哦）</p>
<hr>
<p>参考：<br> <a href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work" target="_blank" rel="noopener">stackoverflow的大大~</a><br> <a href="https://developer.mozilla.org/cn/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">MDN文档</a><br>《Javascript高级程序设计》第2版–Nicholas C. Zakas 第7章<br>《Javascript设计模式与开发实践》–曾探  第3章</p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript厉害的Array]]></title>
      <url>https://disinuo.me/2017/01/19/2017-01-19-javascript_array/</url>
      <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>虽然javascript数据类型少，但是功能还是挺多的~<br>比如Array类型！又可以当栈又可以当队列^o^<br>而且Array还有一个特点是：一个Array里面的每一项都可以是不同的类型~也算是一个有利有弊的特性吧~</p>
<h3 id="能当栈又能当队列"><a href="#能当栈又能当队列" class="headerlink" title="能当栈又能当队列"></a>能当栈又能当队列</h3><p>为了实现这一点，javascript的Array有4个方法<br>分别是pop,push,shift,unshift。<br><a id="more"></a><br>作用分别是对Array尾部弹出一项、尾部添加N项、头部弹出一项、头部添加N项。（N&gt;=1）<br>返回值分别是弹出项、Array的最新长度、弹出项、Array的最新长度。<br>于是！基于这4个操作~<br>pop和push组合，或shift和unshift，就可以模拟出 <strong>栈</strong> 的操作<br>pop和unshift组合，或shift和push, 就可以模拟出 <strong>队列</strong> 的操作<br>下面看看例子吧~<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array=[<span class="string">'aaa'</span>,<span class="string">'bbb'</span>,<span class="string">'ccc'</span>,<span class="string">'ddd'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'original array: '</span>+array);</span><br><span class="line"><span class="keyword">var</span> x=array.push(<span class="string">'ccc'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x);     <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">//aaa,bbb,ccc,ddd,ccc</span></span><br><span class="line"><span class="keyword">var</span> y=array.push(<span class="string">'eee'</span>,<span class="string">'fff'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(y);     <span class="comment">//7</span></span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">//aaa,bbb,ccc,ddd,ccc,eee,fff</span></span><br><span class="line"><span class="keyword">var</span> z=array.pop();</span><br><span class="line"><span class="built_in">console</span>.log(z);     <span class="comment">//fff</span></span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">//aaa,bbb,ccc,ddd,ccc,eee</span></span><br><span class="line"><span class="keyword">var</span> m=array.shift();</span><br><span class="line"><span class="built_in">console</span>.log(m);     <span class="comment">//aaa</span></span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">//bbb,ccc,ddd,ccc,eee</span></span><br><span class="line"><span class="keyword">var</span> n=array.unshift(<span class="string">'ggg'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(n);     <span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">//ggg,bbb,ccc,ddd,ccc,eee</span></span><br><span class="line"><span class="keyword">var</span> p=array.unshift(<span class="string">'hhh'</span>,<span class="string">'iii'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p);     <span class="comment">//8</span></span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">//hhh,iii,ggg,bbb,ccc,ddd,ccc,eee</span></span><br><span class="line"><span class="comment">// 这最后一种情况要注意一下~</span></span><br><span class="line"><span class="comment">// 我原本以为会是 iii,hhh,...的，</span></span><br><span class="line"><span class="comment">// 因为想的是按照插入的顺序，先在头部插入hhh，再在头部插入iii嘛</span></span><br><span class="line"><span class="comment">// 结果hhh在iii的前面了。</span></span><br><span class="line"><span class="comment">// 再经思考，</span></span><br><span class="line"><span class="comment">// 觉得这大概跟'javascript的函数所有参数其实是一个数组'有关，</span></span><br><span class="line"><span class="comment">//（就是在实现上，函数的参数会合并起来成为一个数组，就是`arguments`,在函数内部可以通过arguments[i]依次访问传入的参数~~ 虽然严格来讲它不是数组，是类数组，但这里就不多说啦）</span></span><br><span class="line"><span class="comment">// 于是这里hhh,iii被看成一个数组，直接插入到原数组头部</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/disinuo/Demo_for_learningJS" target="_blank" rel="noopener">想看源码可以戳这里^ ^</a>（还包含javascript系列的其他部分的源码哦~~）~</p>
<hr>
<p>参考：<br>《Javascript高级程序设计》第2版–Nicholas C. Zakas 第5章</p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[警惕javascript的内存泄漏]]></title>
      <url>https://disinuo.me/2017/01/18/2017-01-18-javascript_memory_rename/</url>
      <content type="html"><![CDATA[<p>javascript的BOM和DOM对象是基于C++的COM的，它的垃圾收集机制是<font color="#e06c75">引用计数策略</font>，<br>循环引用会造成内存泄漏。</p>
<h3 id="引用计数策略思想"><a href="#引用计数策略思想" class="headerlink" title="引用计数策略思想"></a>引用计数策略思想</h3><p>跟踪变量被引用的次数，次数为0的会被回收</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ele=<span class="built_in">document</span>.getElementById(<span class="string">'id'</span>);</span><br><span class="line">  <span class="keyword">var</span> obj=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  ele.obj=obj;</span><br><span class="line">  obj.ele=ele;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DOM元素与一个javascript原生对象建立了循环引用。<br>即使func执行完，两个对象都被两一个对象引用着，被引用数永远不会为0，<br>于是两个对象也永远不会被自动回收。<br>就出现了内存泄漏</p>
<h3 id="应对策略"><a href="#应对策略" class="headerlink" title="应对策略"></a>应对策略</h3><p>暂时知道的办法就是。。。在结束使用对象的时候，<br>手动断开两对象的连接：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ele.obj=<span class="literal">null</span>;</span><br><span class="line">obj.ele=<span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 是的这样就可以了！</span></span><br><span class="line"><span class="comment">// 这样基于引用计数策略的垃圾回收器在下次检查的时候</span></span><br><span class="line"><span class="comment">// 就会发现他们的引用数变成了0，就把它们回收了~~</span></span><br></pre></td></tr></table></figure></p>
<p>不过现在javascript的主流垃圾回收算法是“标记清除”啦，大概思想是给当前不使用的值加上标记，然后再回收。<br>所以除了在IE中访问非原生的javascript对象（比如DOM、BOM）这种情况，其他的都不必担心循环引用造成内存泄漏。</p>
<hr>
<p>参考：<br>《Javascript高级程序设计》第2版–Nicholas C. Zakas 第4章</p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 内存泄漏 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript关键字new]]></title>
      <url>https://disinuo.me/2017/01/10/2017-01-10-javascript_new/</url>
      <content type="html"><![CDATA[<p>关键字new,相当于让解释器帮你加入两行代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>=<span class="built_in">Object</span>.create(ClassName.prototype);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure></p>
<p>举个例子<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Animal=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype=&#123;</span><br><span class="line">  sleep:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"sleeping~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog=<span class="keyword">new</span> Animal(<span class="string">'dogge'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog.name);      <span class="comment">//dogge</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.sleep());   <span class="comment">//sleeping</span></span><br><span class="line"><span class="comment">// 用关键字new，解释器会将Animal自动添加上述的两行代码</span></span><br><span class="line"><span class="comment">// 变成下面的样子</span></span><br><span class="line"><span class="keyword">var</span> Animal=<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>=<span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不用`new`呢</span></span><br><span class="line"><span class="keyword">var</span> cat=Animal(<span class="string">'Kitty'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cat);       <span class="comment">//undefined。因为Animal方法没有返回值</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[或许我们都是盲人---读《失明症漫记》的感想]]></title>
      <url>https://disinuo.me/2016/12/25/2016-12-25-blind_disease/</url>
      <content type="html"><![CDATA[<font color="#DCACAC"><strong>我们都是盲人，看得见的盲人，能看却又看不见的盲人。</strong> </font>

<a id="more"></a>
<hr>
<p>这是一本，每个角色都没有名字的书，一本脑洞很大、细节却又很真实让人很信服的书，一本讽刺现实的书。<br>  而且不得不说，这是一本压抑的书。<br>  看的过程中真的有过窒息的感觉，不能再继续看下去了要干点别的事调剂一下，但等缓过来点的时候又迫不及待的拿起来继续看。</p>
<p>  书一上来就详细描写了一个男子开着车突然失明的过程。接着，一个送他回家，随后动了歹念偷他车的‘好心人’也失明了，接下来可想而知——越来越多的人失明。不过作者萨拉马戈着力塑造了本书的几个主要人物：眼科医生，戴眼罩的老人、戴墨镜的姑娘、斜眼的小男孩，这三个人都去这位医生那里看过眼疾，另外还有一个酒店女服务员，还有前面提到的第一个失明者和偷车的人。然而还有一个特别的人—–医生的妻子，她没有失明，也是‘失明症’席卷全球的时候唯一一个没有失明的人。<br>  当我内心正吐槽着这情节的荒谬—-失明可以传染—-的时候，接着，政府为了不让民众恐慌，也似乎是当时情况下他们能想到的唯一办法–把患了‘白色眼疾’的人关到一起，隔离起来。【对，白色眼疾，这些失明的人眼前不是通常盲人的一片漆黑，而是‘仿佛涌进牛奶的白’，明亮而刺眼的白。】然后我就知道，恩，要发生点什么了。对了，医生的妻子会出现在盲人群体里是因为来抓医生的时候她谎称自己也失明了，我当时还被这坚贞的爱情感动了一会~<br>  他们被安排到了一个闲置的精神病院里，由士兵在大门处看管。</p>
<p>  起初人比较少，气氛还相对和谐。但抱怨是少不了的，一是好好的生活突然被‘失明’打断，丧失了大半的生活能力，还不管三七二十一就被抓来在这区区十几平米的宿舍里跟陌生人一起生活；二来是士兵根本不把他们当人看，自然这是政府授意的—<strong>‘虫子死了，毒汁就没了’</strong>。。。每天广播都会播报“每天3次送饭，所有盘子盒子餐具一类的剩余物品应焚烧；焚烧产生的一切不良后果由住宿者承担；如果发生火灾，不管是意外还是人为，消防人员皆不来救；内部出现任何疾病、殴斗，外界均不介入；若有人死亡，不管什么死因，均由住宿者在围栏旁掩埋尸体，不举行任何仪式。”最后还加上一句“政府和全民族都希望你们履行自己的义务”。<br>  第一次看到这段广播的时候我毛骨悚然，多么冷酷无情，我以为当真的有人受伤需要诸如止血药物的时候，他们会心软下来派人送药。<br>  事实证明我的想法是多么的天真可笑。<br>  一个腿部受伤，已经严重感染的盲人，同伴去要过药品无果决心自己去试一试。本来当萨拉马戈写到他趁别人都在睡觉的时候，终于不能忍受疼痛爬起来，爬出去，我以为他是要去自我了断的。但接下来萨拉马戈用了很长的文字描写了盲人的内心，想象着自己被送到医院，肯定会有收留瞎子的医院，被医治后即使再把他送回来也无所谓。这样的乐观心态势必预示着悲伤的结局。我做好了士兵态度恶劣的拒绝他的心理准备。<br>  他历经了常人难以想象的艰辛如何背朝前用双手支撑身体下了那么多级台阶，如何趴在地上匍匐着朝门爬去。<br>  然而。<br>  枪响了。一连几发。<br>  盲人到了门口站起身—-突然的出现吓了站岗的士兵一跳。<br>  刚还梦想着自己痊愈的人，倒在了血泊中，或许他永远也不知道自己是怎么死的。。。</p>
<hr>
<p>  随后有越来越多的人住进来，原本就狭小的空间变得拥挤不堪。<br>  其实每个人刚进来的时候都幻想着自己有一天会好，可是时间逐渐耗尽了他们的耐心。。。</p>
<p>  因为看不见，有的人仿佛享受着这种‘做事不用负责任’的快感。起初大家都是摸索着找到厕所解决生理问题的，但因为日积月累厕所已然不堪重负，加上有人或是忍不住或是懒，就在走廊里甚至是宿舍里解决了。<br>    <font color="#DCACAC">一个坏的开始往往会紧接着人们的争相效仿。</font><br>  很快走廊里遍地都是。。。不可描述的排泄物。。。臭气熏天，甚至可以说是毒气。<br>  在这样的环境下更不用说洗澡了。于是每个人都达到了自己有生以来的邋遢巅峰。<br>  每个人都活得不像人了。<br>  医生的妻子只能尽自己所能的帮助大家—–只有丈夫知道她看得见。想想也知道她告诉大家自己看得见的后果—-变成奴隶。<br>  但这一切跟接下来要发生的事比起来，简直算是幸福的日常生活。</p>
<p>  一个仗着有一把枪的宿舍要当老大。他们抄起家伙围住所有食物声称给钱才能吃东西。<br>  我当时也是不懂在那样的情况下要钱还有什么用，或许只是想宣示自己的权威吧。<br>  虽然很不情愿，但也别无他法。<br>  本来就如此悲催了竟然还要被抢劫。<br>  强盗们显然没有满足于此，接着要求每个宿舍轮流派来所有女人‘服淫役’。<br>  我当时心中一万个草泥马呼啸而过，然而可怕的是，几乎紧接着，我竟觉得‘这好像很正常’。<br>  在这里这么久了难免会有生理需求，如果换做我是那强盗中的一员，手握如此至高无上的权威，我可能也会动这个心思吧。<br>  <font color="#DCACAC">所以令人毛骨悚然的不是卑鄙的人如何卑鄙，而是想到如果是我，我也会这么做。</font><br>  强盗们的饥渴转化成了如禽兽般的粗鲁。甚至有一个女人回到宿舍没多久就死了。</p>
<hr>
<p>  终于有一天，所有人，所有人都失明了（除了医生的妻子，具体为什么就不要深究啦~）<br>  他们于是逃离了精神病院。<br>  小说的几个主要人物结伴而行，医生的妻子随后告诉了他们自己看得见的事实。<br>  大家出乎意料的平静。<br>  或许经历了这一切已经对一切事情麻木；或许早已发现只是不敢确定；或许觉得’那又怎样的，我可能永远也不会康复’。<br>  但妻子无疑担起了照顾大家的重任。首要任务就是寻找食物。好不容易找到了一个大超市，摸索到了食物。而返回同伴居住地的过程亦是艰辛而漫长。<br>  当食物吃完，妻子再次找到那个超市，虽已做好食物被人发现而抢空的心理准备，见到的场景却还是令她狂呕不止。<br>  一个半掩着门的小房间里，全是死尸。<br>  看样子是有人绊倒了，一个接一个的绊倒，外面求食心切的人于是把他们从外面锁起来。<br>  人心可怕。<br>  最终所有人，所有还活着的人，一个接一个的复明了。<br>  而萨拉马戈借医生妻子之口说出了这样意味深远的话<br>  <font color="#DCACAC">“我想我们现在是盲人；能看得见的盲人；能看但又看不见的盲人”</font></p>
<hr>
<p>  写到这里突然发现好像是在概述小说了，可是真的是太过震撼，特别想把印象深刻的情节描述一遍。<br>  小说里几处设定我觉得也颇具深意。</p>
<ul>
<li><font size="3"><strong>‘白色’眼疾</strong></font><br>在人们的既定思维里，白色，代表着白天，代表着光明。而萨拉马戈却反其道而行之，盲人眼前是无尽的白色，“从此盲人的世界里再无黑暗”。<br>而事实上他们所处的这个世界，或者说他们所创造的这个世界，充斥着自私、凌辱等无尽的黑暗力量。<br>真是莫大的讽刺。<br>而相对应的，最后盲人们在复明之前，却是先经历了黑暗，第一个复明的盲人经历黑暗的时候还以为自己‘转化成了另一种失明’，但随后到来的，是重见光明。</li>
<li><font size="3"><strong>妓女也有感情</strong></font><br>小说中‘戴墨镜的姑娘’其实是一个妓女。人们都对妓女有偏见。固然这是一个不光彩的职业，没错，但人们往往觉得‘妓女没有情感’，‘妓女都是不孝的’。<br>可从他们逃离了精神病院的那一刻起，戴墨镜的女人就惦记着找自己的父母，即便理智的思考一下都知道找到的可能微乎其微，但她不想放弃哪怕一丝希望。后来在医生妻子的带领下回到家里，剪下了一头长发留给父母做信号。后来复明也是第一时间回家里给父母留字条。<br>奇迹这种事，谁说的准呢。</li>
</ul>
<ul>
<li><font size="3"><strong>每天滴眼药</strong></font><br>戴墨镜的姑娘患有结膜炎。萨拉马戈多次描写过她为自己滴眼药水的情景。或许是习惯，又或许是这无尽的绝望中仍抱有一丝希望，尽管这一切看起来很可笑。<br>而后半部分，又多次从医生妻子的角度诉说，<br>“她的眼病已经治好了，可是她不知道”。。。</li>
<li><font size="3"><strong>悲伤超越了爱情</strong></font><br>宿舍里还有一对夫妻，很少说话。因为他们当下的悲伤超越了爱情。<br>是啊，每个人都丧失了最基本的生活能力，为了活下去身心俱疲，甚至已经不能称为‘人’了，又有什么爱情可言呢。</li>
<li><font size="3"><strong>灾难催生奇妙的情感</strong></font><br>也不是都这么悲观。戴墨镜的姑娘和戴眼罩的老人之间，产生了一种很奇妙的情感。<br>我认为与其说是爱情，更多的像是身处绝境的人之间的惺惺相惜，是一种坚不可摧的亲情。<br>于是他们许下守护彼此一生的誓言，纵使老人的年龄足以做姑娘的父亲。<br>就算后来恢复了视力，姑娘真挚地说，<br>“我看到了你满脸皱纹，谢顶，头发花白，但你就是我想一起生活的人”</li>
</ul>
<hr>
<p>最后还想提一下这本小说很有特点的标点用法~<br>全篇对话都没有冒号、引号，没有换行。还是译者范维信教授在不同人物说的话之间加了分号以区分。叙事与对话混杂在一起，或许萨拉马戈这样是为了尽量以一个旁观者的角度讲述这个故事吧，不加入任何情感。</p>
<p>虽然已经‘剧透了很多小说的情节’，但震撼人心的部分远远不止这些，如果你有足够的勇气，就拿起这本书吧。</p>
<p><strong>仔细品味，这盲人的世界，又何尝不是现今世界的一个缩影。</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> 书评 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript之this的绑定]]></title>
      <url>https://disinuo.me/2016/12/24/2016-12-24-javascript_this/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天在<a href="https://cn.udacity.com/" target="_blank" rel="noopener">udacity</a>上听课~觉得老师对javascript里面的this讲得很清楚，总结一下~<br><a id="more"></a></p>
<h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><ol>
<li>看<code>点</code>的左边是什么，this就绑定什么。（回调函数、new有例外,见原则3 &amp; 5）</li>
<li>没有<code>点</code>的话，this就绑定默认值——全局</li>
<li>回调函数大多数是全局，若用一个function包起来则满足原则一</li>
<li><code>functionName.call</code>可以绑定任意变量</li>
<li><code>new r.method(g,b);</code>的this，是一个新生成的对象<br>[总结的可能不大清楚，下面看看例子吧~]<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func=<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>,x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> r=&#123;<span class="attr">id</span>:<span class="string">'r'</span>&#125;,g=&#123;<span class="attr">id</span>:<span class="string">'g'</span>&#125;,b=&#123;<span class="attr">id</span>:<span class="string">'b'</span>&#125;;</span><br><span class="line">r.method=func;</span><br><span class="line"><span class="comment">// -------下面是调用啦-----------------</span></span><br><span class="line">func(g,b);     <span class="comment">// &lt;global&gt;,g,b</span></span><br><span class="line">r.method(g,b); <span class="comment">// r,g,b</span></span><br><span class="line">func.call(r,g,b); <span class="comment">// r,g,b</span></span><br><span class="line">setTimeout(func,<span class="number">10</span>); <span class="comment">// &lt;global&gt;,undefined,undefined</span></span><br><span class="line">setTimeout(r.method,<span class="number">10</span>); <span class="comment">// &lt;global&gt;,undefined,undefined</span></span><br><span class="line">setTimeout(r.method(g,b),<span class="number">10</span>); <span class="comment">// &lt;global&gt;,g,b</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;r.method()&#125;,<span class="number">10</span>);<span class="comment">// r,undefined,undefined</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;r.method(g,b)&#125;,<span class="number">10</span>);<span class="comment">// r,g,b</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//&lt;global&gt;</span></span><br><span class="line"><span class="keyword">new</span> r.method(g,b);<span class="comment">//&lt;object&gt;,g,b</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>首先说一下上面提到的全局<code>&lt;global&gt;</code>，是一个默认存在的Window对象~<br>我在浏览器控制台看到它大概长这样：<br><code>Window {speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…}</code></p>
<p>前5行就不解释了~~下面的就按照行号来说啦</p>
<p>7  没有点，满足原则2。this绑定全局。<br>8  点左边是<code>r</code>，满足原则1。this绑定r<br>9  运用原则4：<code>function.call(&lt;这是一个可选参数&gt;,paramaters...)</code><br>   而这个可选参数就是此函数this绑定的对象。<br>   <code>‘那如果这里我写func.call(g,b)是不是它的this又是全局了呢’</code>你可能会问<br>   并不是。因为它是从前往后对应参数的，意思就是你传了两个参数的话，也是第一个参数作为那个可选参数，第二个参数才作为该函数接口的参数，所以如果<code>func.call(g,b)</code>的话，输出就是<code>g,b,undefined了</code>~<br>10 setTimeout是回调函数，符合原则3的前半句。this绑定全局<br>11 依旧满足原则3前半句。此处虽然有 点 ，但回调函数特殊。<strong>下面有解释</strong><br>12 跟11同理，列出来是想表示回调函数也可以正常传参<br>13 满足原则3后半句，因为点之前是r，所以this绑定r。<strong>下面有解释</strong><br>14 跟13同理<br>15 即使不在方法里，this也不是undefined哦~依旧是默认的全局~<br>16 这个有点迷。老师说带new的话，this绑定的是一个新生成的对象，而且每这样new一个，就会新生成一个对象。//这种情况没太理解，那个新生成的对象意义到底是什么。希望了解的大神告知~谢谢！~~</p>
<h3 id="关于11、13的原理解释"><a href="#关于11、13的原理解释" class="headerlink" title="关于11、13的原理解释"></a>关于11、13的原理解释</h3><p>setTimeout是js库里面自带的方法，它的结构也无非就是下面这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(func,time)&#123;</span><br><span class="line">  wait_for_a_while(time)   <span class="comment">//这方法是我yy的啊不要当真，就是这么个意思</span></span><br><span class="line">  ----some codes-----</span><br><span class="line">  func();  <span class="comment">//一定会在某个地方调用传进来的方法</span></span><br><span class="line">  ----some codes------</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>于是，11那种<code>r.method</code>的，r.method仅仅是作为一个方法传给了setTimeout，相当于r.method只是这个方法的名字，而不会被解读成r的method方法<br>就是说,在setTimeout里，它根本不知道r的存在<br>可以类比成下面这种情况：（java语言）<br>有一个方法的接口是<code>public void test(int x)</code><br>有一个对象obj，有int类型的属性id，<br>而<code>test(obj.id)</code>这样的调用并不会把obj暴露给方法test，对于它来说x只是一个整数而已。<br>//啰嗦了这么多。。。发现自己表达能力不太够。。。哪里没理解或者有不同见解的欢迎提出！~</p>
<p>而，13那种用function包起来的~setTimeout在执行的时候就会去执行这个匿名函数的函数体~~<br>这个函数体里有一句r.method(),于是setTimeout就会执行r.method啊~于是就满足原则1啦~</p>
<p>哦对了~圣诞快乐！！！~~~~</p>
<hr>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[给github pages设置ssl(包含改了域名的情况)]]></title>
      <url>https://disinuo.me/2016/12/21/2016-12-21-github_pages_setup_ssl/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近才知道http和https的区别，然后看到好多文章说http相比较于https怎么怎么没有前景。本来也是觉得我一个博客的网站就http吧也无所谓。但是有的浏览器会警告，看着就很心塞啊，于是找了找教程尝试了一下~<br>如果是用github pages搭建的博客，有两种可能：有没有设置自己的域名~<br><a id="more"></a></p>
<h3 id="情况1-没有重新设置域名"><a href="#情况1-没有重新设置域名" class="headerlink" title="情况1.没有重新设置域名"></a>情况1.没有重新设置域名</h3><p>就是你的url是<code>yourname.github.io</code>这种的，<br>这个就比较简单啦~github直接就可以配置(不过这个我没试~)<br>在github上进入你名为yourname.github.io的仓库-&gt;settings<br><img src="/image/2016-12-21-github_pages_setup_ssl/github.png" alt><br>然后找到图片中的<code>Enforce HTTPS</code>，勾选上就ok了（因为我设置了自己的域名所以它不让我选）</p>
<h3 id="情况2-设置了自己的域名"><a href="#情况2-设置了自己的域名" class="headerlink" title="情况2.设置了自己的域名"></a>情况2.设置了自己的域名</h3><p>比如我设置成了disinuo.me</p>
<ol>
<li><strong><a href="https://www.cloudflare.com/a/login" target="_blank" rel="noopener">注册Cloudflare</a></strong><br>Cloudflare是什么？它是一家免费CDN网站加速服务公司，还提供实时安全保护服务和网络优化等。【恩这是google到的，我现在还不太懂CDN是什么。。想了解Cloudflare的话可以去他官网主页看看~^ ^】</li>
<li><strong>填写域名</strong><br><img src="/image/2016-12-21-github_pages_setup_ssl/0.png" alt><br>比如我是<code>disinuo.me</code>,点begin scan就开始扫描你的网站啦<br>扫描结果如下，然后点continue<br><img src="/image/2016-12-21-github_pages_setup_ssl/1.png" alt></li>
<li><p><strong>选择计划</strong><br>默认是Business Website。我选的是上面那个免费的~^ ^<br><img src="/image/2016-12-21-github_pages_setup_ssl/2.png" alt></p>
</li>
<li><p><strong>修改NameServer</strong><br><img src="/image/2016-12-21-github_pages_setup_ssl/3.png" alt><br>会列出了两个nameserver，提示你去域名商那里修改<br>我是在万网购买的域名~于是去<a href="https://netcn.console.aliyun.com/core/domain/list" target="_blank" rel="noopener">阿里云的域名控制台</a>修改<br><img src="/image/2016-12-21-github_pages_setup_ssl/4.png" alt><br>点<code>管理</code>会出现下图<br><img src="/image/2016-12-21-github_pages_setup_ssl/5.png" alt><br>之后修改成cloudflare提供的nameserver就好啦~</p>
</li>
<li><strong>设置为flexible ssl</strong><br>其实这个默认就是设置成flexible的，就是说这一步可以不用管~<br>不过还是在这里贴一下去哪设置好了，就在主页点图示的<code>flexible</code>就可以修改啦<br><img src="/image/2016-12-21-github_pages_setup_ssl/6.png" alt></li>
<li><strong>耐心的等待</strong><br>然后就好啦~就是等啦！他官网上面说最多24小时可以生效。<br>我以为它就是客气客气。。。没想到我真的等了24小时。。。<br>所以如果好久也没生效别急哈~再等等<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之后就可以通过`https://yoursite`访问啦</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>其实Cloudflare的引导做的很好的，每一步都说的很清楚~也许你都不需要跟着本教程一步一步的走，不过还是希望多少帮助到了你一点~^ ^</li>
<li>现在访问<code>http://yoursite</code>还不能自动跳转到https的，待我再研究研究再来更新~</li>
</ul>
<hr>
<p>参考链接：<br><a href="https://sheharyar.me/blog/free-ssl-for-github-pages-with-custom-domains/" target="_blank" rel="noopener">Set Up SSL on Github Pages With Custom Domains for Free </a><br><a href="http://www.xujiahua.com/4680.html" target="_blank" rel="noopener">cloudflare.com是什么？新手入门中文注册使用教程</a></p>
]]></content>
      
        
        <tags>
            
            <tag> ssl </tag>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[preparedStatement 报错 Parameter index out of range (1 > number of parameters, which is 0)]]></title>
      <url>https://disinuo.me/2016/12/18/2016-12-18-preparedStatement_Parameter_index_out_of_range/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>还是在写j2ee作业。。。（写这作业真的是遇到了好多坑啊。。。orz），servlet跟数据库交互，进行sql查询嘛。<br>本来都好好的也测试过的，然后sql语句换了一个复杂一点的就开始报如题的错。。。我想这是没读到我的问号喽？<br>可是问号明明就在那里orz<br><a id="more"></a></p>
<h3 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String sql=<span class="string">"SELECT exam.id as examID,"</span>+</span><br><span class="line"><span class="string">"exam.name as examName,"</span>+</span><br><span class="line"><span class="string">"exam.date as examDate,"</span>+</span><br><span class="line"><span class="string">"selectC.cid as courseID,"</span>+</span><br><span class="line"><span class="string">"course.name as courseName "</span>+</span><br><span class="line"><span class="string">"FROM selectC,exam,course "</span>+</span><br><span class="line"><span class="string">"WHERE selectC.cid = exam.cid "</span>+</span><br><span class="line"><span class="string">"AND course.id=selectC.cid "</span>+</span><br><span class="line"><span class="string">"AND selectC.sid = ?"</span>;</span><br><span class="line">pstmt=cnn.prepareStatement(sql);</span><br><span class="line">pstmt.setString(<span class="number">1</span>, param);</span><br><span class="line">ResultSet rs=pstmt.executeQuery();</span><br></pre></td></tr></table></figure>
<p>看起来没毛病吧!我后来都想是不是问号打成中文字符的问号了，改了一下还是不行<br>然后。。。求助google，也没人遇到类似问题，</p>
<p><font color="red" size="4">报同样错的网友们大多是,把问号用单引号包起来了</font></p>
<p><font color="red" size="3">像这样<code>String sql=&quot;SELECT * FROM user WHERE id = &#39;?&#39;&quot;</code></font><br><em>**</em> # 如果你是这样就把单引号去掉吧~再跑一下看看是不是不报这个错了^ ^<br>然后我也不知道哪来的灵感。。把sql变成了下面这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql=<span class="string">"SELECT exam.id as examID,exam.name as examName,exam.date as examDate,selectC.cid as courseID,course.name as courseName FROM selectC,exam,course WHERE selectC.cid = exam.cid AND course.id=selectC.cid AND selectC.sid = ?"</span>;</span><br></pre></td></tr></table></figure></p>
<p>是的没错就是把追加形式的变成了一个字符串而已<br>然后！！</p>
<p><font size="5">然后！！！</font><br>就好了。。。orz<br>我只是觉得码代码的时候这样写一串看着太累就拆开了呀。。。好委屈。。。</p>
<h3 id="找原因"><a href="#找原因" class="headerlink" title="找原因"></a>找原因</h3><p>然后我想找一找为什么这么改就好了。。这两个有什么区别呢。。。没找到<br>而且我今天又试了试（写这里的时候是出现bug的第二天），把sql语句又改成原来追加的形式。。它又不报错了。。。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以不好意思浪费了看本篇文章的你这么多时间。。<br>不过还是希望你如果遇到了同样的报错，<br>可以通过文中红色字提到的 <code>把包裹问号的单引号去掉</code>成功修复~ ^ ^</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
            <tag> j2ee </tag>
            
            <tag> sql </tag>
            
            <tag> jdbc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mac mysql5.7 安装完无法登录使用]]></title>
      <url>https://disinuo.me/2016/12/15/2016-12-15-mysql5.7_login_fail/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>mysql 5.7 安装完有默认初始密码了，而且不是root…</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>准备写j2ee作业，老师让安装mysql5.7,我下载的是dmg文件。<br>可是安装完之后，我打开终端输入<code>mysql</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ERROR</span> 1045 (28000): Access denied <span class="keyword">for</span> user <span class="string">'root'</span>@<span class="string">'localhost'</span> (using password: NO)</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>然后我又输入<code>mysql -u root -p</code>，之后把安装的时候弹窗提示的初始密码输进去 [对就是超奇怪的一串字符]。。还是不行</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>还是在stackoverflow上找到了解决办法！贴过来~<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先打开一个终端窗口，然后执行下面指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行下面stop这条指令我会报错,但手欠把那个终端关了忘记什么错了。。</span></span><br><span class="line"><span class="comment"># 反正查了一下这指令是关闭mysql服务器的，</span></span><br><span class="line"><span class="comment"># 我就直接手动去【系统偏好设置】那里关的</span></span><br><span class="line"><span class="variable">$sudo</span> /usr/<span class="built_in">local</span>/mysql/support-files/mysql.server stop  </span><br><span class="line"><span class="variable">$sudo</span> /usr/<span class="built_in">local</span>/mysql/bin/mysqld_safe --skip-grant-tables</span><br><span class="line"><span class="comment"># 这时不要关这个窗口，新打开一个终端窗口</span></span><br><span class="line"><span class="variable">$sudo</span> /usr/<span class="built_in">local</span>/mysql/bin/mysql -u root</span><br><span class="line">mysql&gt;use mysql</span><br><span class="line">update user <span class="built_in">set</span> authentication_string=password(<span class="string">'yourNewPassword'</span>) <span class="built_in">where</span> user=<span class="string">'root'</span>;</span><br><span class="line"><span class="comment"># yourNewPassword换成你要设置的密码</span></span><br></pre></td></tr></table></figure></p>
<p><strong>然后就大功告成啦！~</strong></p>
<h3 id="感谢stackoverflow的大大"><a href="#感谢stackoverflow的大大" class="headerlink" title="感谢stackoverflow的大大"></a>感谢stackoverflow的大大</h3><p><a href="http://stackoverflow.com/questions/33033306/mysql-5-6-27-reset-root-password-no-password-field/33443921#33443921" target="_blank" rel="noopener">这里是stackoverflow的原回答</a><br>但是我刚注册声誉值不够不能点赞。。。orz<br>如果这也刚好解决了你的问题而且你声誉值够高的话~去点个赞吧！~~~^o^</p>
<h6 id="PS：这两天注册了好几个技术类问答平台。。都好多权限限制。。。作为新手玩家的我感受到了世界深深的恶意。。。我要争取总去刷一刷！"><a href="#PS：这两天注册了好几个技术类问答平台。。都好多权限限制。。。作为新手玩家的我感受到了世界深深的恶意。。。我要争取总去刷一刷！" class="headerlink" title="PS：这两天注册了好几个技术类问答平台。。都好多权限限制。。。作为新手玩家的我感受到了世界深深的恶意。。。我要争取总去刷一刷！"></a>PS：这两天注册了好几个技术类问答平台。。都好多权限限制。。。作为新手玩家的我感受到了世界深深的恶意。。。我要争取总去刷一刷！</h6><hr>
]]></content>
      
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git分支管理(二)---合并]]></title>
      <url>https://disinuo.me/2016/12/14/2016-12-14-git_branch_merge/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本来没想到分支能写这么长的。。于是就拆成两篇了~想看另一篇的可以<a href="http://disinuo.me/2016/12/14/2016-12-14-git_branch/">戳这里 git分支管理(一)—创建、提交、切换</a>^ ^<br><a id="more"></a></p>
<h3 id="指针机制"><a href="#指针机制" class="headerlink" title="指针机制"></a>指针机制</h3><p>git 的每个commit都是一个节点，每条分支都有一个head指针指向该分支最新的节点。<br>比如下图有紫色分支和绿色分支，每个圆圈是一个commit节点，红色外框的圆圈是该分支的head指针指向的节点。</p>
<ul>
<li><strong> 紫色是master分支，绿色是dev分支 </strong><br><img src="/image/2016-12-14-git_branch_merge/head.png" alt></li>
</ul>
<h3 id="两种合并方式"><a href="#两种合并方式" class="headerlink" title="两种合并方式"></a>两种合并方式</h3><ul>
<li><h4 id="Fast-Forward-ff"><a href="#Fast-Forward-ff" class="headerlink" title="Fast Forward --ff"></a>Fast Forward <code>--ff</code></h4>这是一种当其中一个分支没有新节点时的默认的合并方式（以下简称FF）<br>(就是你不必加<code>--ff</code>这个参数，如果可以用这种方式合并git自然会用这种方式的)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br><span class="line"><span class="comment"># 当前在master分支下，执行此命令会默认进行fast forward 合并</span></span><br><span class="line"><span class="comment"># 将dev合并到master</span></span><br><span class="line"><span class="comment"># 合并之后提交线变成一条线，两个分支的head是同一个节点</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/image/2016-12-14-git_branch_merge/fast.png" alt></p>
<ul>
<li><h4 id="Not-Fast-Forward-no-ff"><a href="#Not-Fast-Forward-no-ff" class="headerlink" title="Not Fast Forward --no-ff"></a>Not Fast Forward <code>--no-ff</code></h4><p><img src="/image/2016-12-14-git_branch_merge/no-ff.png" alt></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff dev</span><br><span class="line"><span class="comment"># 新建一个节点！</span></span><br><span class="line"><span class="comment"># 合并之后依旧可以从提交线中清晰地看出不同分支的commit历史</span></span><br><span class="line"><span class="comment"># dev分支的head没有变哦</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行完这个指令会进入vim，让你输入新节点要commit的信息</li>
<li>作为一个刚会用vim没多久的小白。。贴一下vim基本用法好了~~</li>
<li>输入<code>i</code>之后允许输入；输入结束后按<code>Esc</code>；<code>:wq</code>保存并退出vim</li>
</ul>
</li>
<li><h4 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h4><p>  最主要的差别其实就是提交线图不同：FF是一条线，noFF是多条线。</p>
<p>  NoFF的优点很强势~<br>  比如项目开发过程中，一般都是用master放比较稳定的代码，而在另外创建一个分支上写代码，测试好了再合并到master上。可能会有不同的功能点用不同的分支啊，或者不同的开发者用不同的分支之类的。如果是NoFF合并，就可以用git可视化工具清晰地看到各个分支的详细情况，便于追踪。<br>  比如下图是我上学期的一个大作业。我们团队四个人的提交线的部分(一个master和每人一个分支)~</p>
<p>  <img src="/image/2016-12-14-git_branch_merge/commit_graph.png" alt><br>  而如果是FF合并就惨了。。都在一条线上。。很难找的~<br>  不过要是很小型的项目的话用FF会省事一点喽，就不用每次合并都搞一个新节点出来~<br>  自己视情况权衡利弊吧 ^ ^</p>
</li>
<li><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>写这篇博客之前查了好多资料，好多人说FF合并，分支删掉之后会丢失分支信息，我当时还以为是节点会丢失~<br>然而亲测并没有。所以猜测那些人指的应该是会丢失分支的独立性吧（就是都混在一起看不出谁是谁啦&gt; &lt;）~<br>我还试了一下，两个分支如果相对于分离点都有新节点(就像本文的第一张图)，但是改动的代码没有冲突，git会不会默认使用FF合并。<br>亲测不会。而且我还试着加<code>--ff</code>参数强制FF合并，也还是执行了NoFF合并~<br>就这些吧~等哪天研究一下git提交冲突的再来发文~~</li>
</ul>
<p>PS：为了测试各种情况，快看我今天github上activity程度哈哈哈~创我历史新高~~~<br><img src="/image/2016-12-14-git_branch_merge/github_activity.png" alt></p>
<hr>
<p>参考：<br><a href="https://sandofsky.com/blog/git-workflow.html" target="_blank" rel="noopener">Benjamin Sandofsky的Understanding the Git Workflow</a><br><a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">阮一峰的《git分支管理》</a><br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000#0" target="_blank" rel="noopener">廖大大的《创建与合并分支》</a><br>【文中前3张图都来自<a href="https://sandofsky.com/blog/git-workflow.html" target="_blank" rel="noopener">Understanding the Git Workflow</a>~】</p>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git分支管理(一)---创建、提交、切换]]></title>
      <url>https://disinuo.me/2016/12/14/2016-12-14-git_branch/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为怕代码被我玩坏。。。一直没用过branch。。。今天查了一波~把觉得比较有用的知识整理下~<br><a id="more"></a></p>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch dev    <span class="comment">#创建一个名叫dev的分支，dev不用加引号</span></span><br><span class="line">git checkout dev  <span class="comment">#切换到dev分支</span></span><br><span class="line"><span class="comment">#上述两步可以合并为一步</span></span><br><span class="line">git checkout -b dev <span class="comment">#创建并切换到dev分支</span></span><br></pre></td></tr></table></figure>
<h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch  <span class="comment">#可以查看所有分支</span></span><br><span class="line"><span class="comment">#会看到如下输出，*代表当前处于那个分支下</span></span><br><span class="line">* dev</span><br><span class="line">master</span><br></pre></td></tr></table></figure>
<h3 id="在分支上提交"><a href="#在分支上提交" class="headerlink" title="在分支上提交"></a>在分支上提交</h3><p>过程与普通的提交一样<br>比如对README.md进行了修改，想在dev分支上提交<br>首先要保证切换到分支下 <code>git checkout dev</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">"branch test"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>执行完4 就完成了在dev分支上的提交啦<br>现在我们可以<code>git checkout master</code>切换回主分支看看~<br>然后就会发现README.me是修改前的样子~~~<br>【再切换回dev分支README.me又变成修改后了。我不会承认我来回切换了好多次哈哈哈。。。还是觉得很神奇的】</p>
<ul>
<li><h4 id="5-1-一个小思考"><a href="#5-1-一个小思考" class="headerlink" title="5.1.一个小思考"></a>5.1.一个小思考</h4><p>结合网友们的讨论，以及n多次的试验，<br>我发现如果对某个文件改动，但是不add就切换分支，工作区的改动都是在的（工作区说白了就是本地你看到的代码），即便是add了但不commit就切换分支也依旧如此。<br>而且如果你改动了某个文件，在分支A下<code>git add</code>，但是在分支B下<code>git commit</code>的，最终这个修改是会记录在分支B下的。<br>这也算是一定程度上验证了我在<a href="http://localhost:4000/2016/12/12/2016-12-12-git_note/" target="_blank" rel="noopener">git修改撤销</a>那篇文章里画的图^ ^<br><img src="/image/2016-12-12-git_note/git_4_things.png" alt></p>
<p>那为什么在分支间的切换，本地的工作区代码会有不同呢？下面说下我的理解：<br>add+commit相当于是把改动从工作区【<strong>转移</strong>】到本地版本库的过程,就是说commit之后工作区就clear了。</p>
<ul>
<li>对于工作区clear了的情况，工作区代码会显示成版本库最后一次commit的样子；</li>
<li>对于工作区不是clear的（就是有改动没有commit），工作区代码会将这些没commit的代码显示出来~<br>所以上面我玩的不亦乐乎的分支切换[捂脸]就是因为改动都commit了~工作区clear了~两个分支就会分别显示各自最后一次commit的代码啦!^ ^</li>
</ul>
</li>
</ul>
<h3 id="push新分支"><a href="#push新分支" class="headerlink" title="push新分支"></a>push新分支</h3><p>接下来！如果想push这个新的分支以至于在github可以看到，就要执行这个带参数的push<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git push --<span class="built_in">set</span>-upstream origin dev  </span><br><span class="line"><span class="comment"># 直接git push会报错的</span></span><br><span class="line"><span class="comment"># fatal: The current branch test has no upstream branch.</span></span><br><span class="line"><span class="comment"># To push the current branch and test the remote as upstream</span></span><br></pre></td></tr></table></figure></p>
<h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>我发现好像大部分情况还是本地保留分支的，只是在分支上进行开发，然后合并到主分支上。<br>所以分支的合并显得尤为重要~而且分支的合并还是有不同方式的<br>【感觉再写有点长了，想看分支的合并我们下一篇见吧~^ ^】</p>
<hr>
<p>参考：<br><a href="https://sandofsky.com/blog/git-workflow.html" target="_blank" rel="noopener">Benjamin Sandofsky的Understanding the Git Workflow</a><br><a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">阮一峰的《git分支管理》</a><br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000#0" target="_blank" rel="noopener">廖大大的《创建与合并分支》</a></p>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mac Dock图标错误、消失]]></title>
      <url>https://disinuo.me/2016/12/14/2016-12-14-mac_Dock_icon_wrong/</url>
      <content type="html"><![CDATA[<p>突然发现自己Dock里面出现了两个ppt，鼠标分别移过去发现是firefox的图标变成ppt的图标了。。。<br>这么醉的事情我还是第一次遇到。。。然后赶紧去应用程序那边看，firefox的图标还是正常的。。。于是我就把它从Dock中删除再重新加入，无济于事<br>后来在Mac讨论区看到网友说是使用CleanMyMac的锅。。。<br>然后找到了解决办法！</p>
<hr>
<p>打开终端执行这两条命令就好<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm ~/Library/Application\ Support/Dock/*.db;</span><br><span class="line">killall Dock</span><br></pre></td></tr></table></figure></p>
<p>上述命令是重置dock的~适用于图标消失【有的网友遇到的问题】和博主这种图标错误的情况~<br>ps：我还怕出事情事先备份了一下里面的db文件，，亲测好用~可放心食用^ ^</p>
]]></content>
      
        
        <tags>
            
            <tag> mac </tag>
            
            <tag> CleanMyMac </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[qq号取消对第三方网站的授权]]></title>
      <url>https://disinuo.me/2016/12/13/2016-12-13-qq_cancel_authority/</url>
      <content type="html"><![CDATA[<h3 id="这是一个取消qq账号对其他网站，app的授权的链接！-https-connect-qq-com-manage-html-appauth-user"><a href="#这是一个取消qq账号对其他网站，app的授权的链接！-https-connect-qq-com-manage-html-appauth-user" class="headerlink" title="这是一个取消qq账号对其他网站，app的授权的链接！ https://connect.qq.com/manage.html#/appauth/user"></a>这是一个取消qq账号对其他网站，app的授权的链接！ <a href="https://connect.qq.com/manage.html#/appauth/user" target="_blank" rel="noopener">https://connect.qq.com/manage.html#/appauth/user</a></h3><p>但是直接在qq或者微信里是打不开的会报错<br><a id="more"></a><br><img src="/image/2016-12-13-qq_cancel_authority/fail.png" alt><br>所以要换个浏览器～亲测 <strong>chrome，safari</strong> 可以，火狐不可以 ，其他的都没试了不清楚。<br>然后要重新登录一下 登陆成功界面就如下图<br><img src="/image/2016-12-13-qq_cancel_authority/list.png" alt><br>【我授过的网站有7页orz不要问我为什么。。好多网站自己都没听过】<br>然后下图取消授权就可以了<br><img src="/image/2016-12-13-qq_cancel_authority/dialog.png" alt><br>取消完界面是不会自动刷新的。。所以你可以搞完一页再一起刷新<br>成功后会有下图的提示～<br><img src="/image/2016-12-13-qq_cancel_authority/success.png" alt><br>感觉这是个还在开发中的平台一样。。希望qq维护人员能走点心。。。</p>
]]></content>
      
        
        <tags>
            
            <tag> qq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git 修改撤销]]></title>
      <url>https://disinuo.me/2016/12/12/2016-12-12-git_note/</url>
      <content type="html"><![CDATA[<p>用github这么久一些基本的东西还是搞不清，今天终于google了一波研究了一下</p>
<h3 id="首先要搞懂4个概念：工作区、暂存区、本地版本库、远程版本库"><a href="#首先要搞懂4个概念：工作区、暂存区、本地版本库、远程版本库" class="headerlink" title="首先要搞懂4个概念：工作区、暂存区、本地版本库、远程版本库"></a>首先要搞懂4个概念：工作区、暂存区、本地版本库、远程版本库</h3><p>为了表意清晰一点，就只画正向的关系啦~关系图如下<br><img src="/image/2016-12-12-git_note/git_4_things.png" alt><br>【其实说白点，工作区，就是本地ide或者记事本里正码着的代码】<br><a id="more"></a></p>
<h3 id="想丢弃工作区里修改的文件（在执行add之前"><a href="#想丢弃工作区里修改的文件（在执行add之前" class="headerlink" title="想丢弃工作区里修改的文件（在执行add之前)"></a>想丢弃工作区里修改的文件（在执行add之前)</h3><p>直接<code>git checkout -- &lt;file&gt;</code><br>执行完这步操作，工作区的指定文件就会被版本库里的最新版本覆盖~<br>可以执行<code>git checkout .</code>丢弃工作区的所有文件（注意checkout和 . 之间有个空格）<br>不过这个操作威力很大哦~要谨慎</p>
<h3 id="想丢弃暂存区的文件"><a href="#想丢弃暂存区的文件" class="headerlink" title="想丢弃暂存区的文件"></a>想丢弃暂存区的文件</h3><p>这里的丢弃其实有点歧义啦，一种是撤销对该文件的add，但工作区仍然保留；一种是既撤销add，工作区也丢弃</p>
<p>先说第一种：<br>执行<code>git reset HEAD &lt;file&gt;</code>  即可<br>此时可以用<code>git status</code>检查一下状态，会发现有文件名为红色的提示，说该文件not staged（就是没添加到暂存区）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   cat/cat.html</span><br></pre></td></tr></table></figure></p>
<p>可以看到终端还会暖心的提醒你有两种操作，第二种checkout就是前面2.提到的，也是这一点的第二种情况——既撤销add，工作区也丢弃~<br>就是先执行<code>git reset HEAD &lt;file&gt;</code>，再执行<code>git checkout -- &lt;file&gt;</code>，<br>就可以把已经添加到暂存区的文件，彻底的从工作区也丢弃了。</p>
<h3 id="如果commit了文件A和文件B，但是发现A不应该commit。。。"><a href="#如果commit了文件A和文件B，但是发现A不应该commit。。。" class="headerlink" title="如果commit了文件A和文件B，但是发现A不应该commit。。。"></a>如果commit了文件A和文件B，但是发现A不应该commit。。。</h3><p>这种，，我目前还不知道有什么好方法，，能撤销A的同时还保留B的修改。。。<br>只能手动copy一份B的代码，然后版本回退<code>$ git reset --hard HEAD^</code>  ，再把刚备份的B粘贴过来，再只commit一下B。。。<br>所以为了避免这种尴尬的情况，记得写一点就commit一下！养成好习惯~~~</p>
<hr>
<p>参考文章：（本文版本回退只是提了一嘴~更详细的信息可以戳下面~ ^ ^）<br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374831943254ee90db11b13d4ba9a73b9047f4fb968d000" target="_blank" rel="noopener">廖大大的《撤销修改》</a><br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000" target="_blank" rel="noopener">廖大大的《版本回退》</a><br><a href="https://git-scm.com/book/en/v2/Git-Basics-Undoing-Things" target="_blank" rel="noopener">git官网文档</a></p>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 变量声明]]></title>
      <url>https://disinuo.me/2016/12/11/2016-12-11-javascript_declaration/</url>
      <content type="html"><![CDATA[<h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><table>
<thead>
<tr>
<th style="text-align:left">日期</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2017-01-24</td>
<td style="text-align:left">发现名字不太合适。。。改个名字。。。</td>
</tr>
<tr>
<td style="text-align:left">2017-01-28</td>
<td style="text-align:left">原来那个现象叫“变量提升”！~~</td>
</tr>
</tbody>
</table>
<hr>
<p>发现这一块很迷啊。。<br>首先来看下问题~<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(foo);</span><br><span class="line">    <span class="keyword">if</span> (!foo) &#123;</span><br><span class="line">        <span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(foo);</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure></p>
<p>你猜两个输出分别是什么呢~答案是undefined和10哦！答错了的话就跟我一探究竟吧！^ ^<br><a id="more"></a><br>其实主要是搞明白第一个为什么是undefined，这个搞明白了后面那个执行完if语句自然就是10了。</p>
<hr>
<h3 id="JavaScript的声明"><a href="#JavaScript的声明" class="headerlink" title="JavaScript的声明"></a>JavaScript的声明</h3><h4 id="函数声明-amp-变量声明"><a href="#函数声明-amp-变量声明" class="headerlink" title="函数声明&amp;变量声明"></a>函数声明&amp;变量声明</h4><p>形如 <code>function foo() {}</code>和<code>var foo</code>的分别是函数声明和变量声明。<br>而JavaScript解释器会把这些声明，统一移到该代码所在作用域的顶部—这个现象叫<code>变量提升</code>(参考 <a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html" target="_blank" rel="noopener">ben cherry的JavaScript Scoping and Hoisting</a>)<br>比如如下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	bar();</span><br><span class="line">	<span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会被解释成下面的样子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x;</span><br><span class="line">	bar();</span><br><span class="line">	x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以本文开头提到的代码会被解释成<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo;<span class="comment">//注意看这里</span></span><br><span class="line">    alert(foo);<span class="comment">//A</span></span><br><span class="line">    <span class="keyword">if</span> (!foo) &#123;</span><br><span class="line">        foo = <span class="number">10</span>;<span class="comment">//注意看这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    alert(foo);<span class="comment">//B</span></span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure></p>
<p>所以alertA处的foo仅仅被声明，还没有被赋值，就是undefined；<br>之后if条件为真，将foo赋值为10，所以alertB处输出10~</p>
<p>那么同理 想一想下面这段代码输出什么呢~<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    alert(a);<span class="comment">//A</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">b();</span><br><span class="line">alert(a);<span class="comment">//B</span></span><br></pre></td></tr></table></figure></p>
<p>答案是A:10，B:1哦~<br>解释一下：<br>跟上面变量声明一样的道理啦，这里的函数声明<code>function a() {}</code>会被解释器提到<code>a=10;</code>的前面去，<br>于是<code>a=10;</code>赋值的其实不是函数b外面的变量a，而是函数b内部的函数a(是不是有点晕。。其实不搞这些重名就没这么多事了。。但是多了解下原理总是好事~^ ^)<br>所以也不要以为return后面的就是死代码哦~这就是一个反例</p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mac基本指令无法识别。。。]]></title>
      <url>https://disinuo.me/2016/11/26/2016-11-26-instructionDisappear/</url>
      <content type="html"><![CDATA[<hr>
<h3 id="故事是这样的"><a href="#故事是这样的" class="headerlink" title="故事是这样的"></a>故事是这样的</h3><p>本来在配环境的，结果不仅环境没配好，吃个饭之后再打开终端发现基本指令都不！能！用！了。。。<br>比如sudo、ls、vi。。。<br>按下回车的结果都是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash:sudo:<span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>然后我就慌慌张张的谷歌了一波  还好有相同遭遇的小伙伴分享经验~~</p>
<hr>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="在终端输入"><a href="#在终端输入" class="headerlink" title="在终端输入"></a>在终端输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">"/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin"</span></span><br></pre></td></tr></table></figure>
<p>执行完之后那些指令就暂时可用啦~不过还要赶紧改一下.bash_profile</p>
<h4 id="在终端输入-1"><a href="#在终端输入-1" class="headerlink" title="在终端输入"></a>在终端输入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -e ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>在文本编辑器里打开该文件，加上这一行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">"/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin"</span></span><br></pre></td></tr></table></figure></p>
<p>然后保存~就好啦~~  ^ ^</p>
]]></content>
      
        
        <tags>
            
            <tag> mac </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[强行删除]]></title>
      <url>https://disinuo.me/2016/09/28/2016-09-28-forceDelete/</url>
      <content type="html"><![CDATA[<p><strong>可解决文件名对应路径过长无法删除的情况</strong></p>
<hr>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>这不是昨天电脑重装了系统嘛，顺便格式化了所有盘（觉得太乱想重新搞一遍），然后跟hexo git有关的东西也要重新弄了。具体细节就不说了，反正是想把一个路径搞错的克隆的仓库删掉，但里面<code>node_modules</code>文件夹里，有路径很长的文件，删除的时候会跳出这样的警告<br><a id="more"></a><br><img src="/image/2016-09-28-forceDelete/alert_delete.png" alt><br> 在网上也找了好久，有一个说可以写一个bat文件执行删除指令的看起来还挺厉害的。。然而。。。敌人太强大（这里提示文件已删除但其实没有删掉）<br><img src="/image/2016-09-28-forceDelete/fail.png" alt></p>
<hr>
<h4 id="解决方法！"><a href="#解决方法！" class="headerlink" title="解决方法！"></a>解决方法！</h4><p>首先，随便找个地方新建一个空文件夹，名字随便。（最好路径、名字都简单点，方便接下来的操作）</p>
<p>然后在开始菜单输入cmd打开命令行。</p>
<p>输入指令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robocopy &lt;空文件夹路径&gt; &lt;要删掉的文件夹路径&gt; /purge   <span class="comment">#注意两个路径之间有一个空格，第二个路径与 /purge之间有一个空格</span></span><br></pre></td></tr></table></figure></p>
<p>比如我执行的指令就是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robocopy D:\help_delete D:\github\blog /purge</span><br></pre></td></tr></table></figure></p>
<p>接下来会看到类似下面的输出<br><img src="/image/2016-09-28-forceDelete/step1.png" alt><br>然后这样<br><img src="/image/2016-09-28-forceDelete/step2.png" alt><br>这就是成功啦~去文件夹里看看吧~是不是已经删掉啦<br><img src="/image/2016-09-28-forceDelete/done.png" alt></p>
<hr>
<h4 id="说说原理"><a href="#说说原理" class="headerlink" title="说说原理~"></a>说说原理~</h4><p>这个robocopy命令呢，有一个参数格式，<br><code>robocopy 源 目标 [option]</code><br>源和目标指的都是文件或文件夹的路径</p>
<p>当这个<code>option</code>是<code>/purge</code>的时候，<br>这条命令代表<code>删去 目标中，不存在于源的 文件/目录</code></p>
<p>所以当我们把源设置成空文件夹时，这条命令的执行就会删掉目标里的所有文件/目录~~~</p>
<p>有没有很强势哈哈哈~~</p>
<p>感兴趣的话可以<a href="http://baike.baidu.com/link?url=8-DJgu88ryyX6aS9Keg4QkdBQWTFTcV79W5LsFJOrW84QvyePoON6q57fKW1vKX8-d29665gxcRN3tuHvhuY2_" target="_blank" rel="noopener">了解更多robocopy指令的不同功能</a>  ^ ^</p>
]]></content>
      
        
        <tags>
            
            <tag> windows </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[markdown文件写的博客怎么加图片]]></title>
      <url>https://disinuo.me/2016/09/26/2016-09-25-addImg/</url>
      <content type="html"><![CDATA[<p>终于会加图片了~~~！<br><a id="more"></a><br>再次请教了<a href="http://www.cylong.com/" target="_blank" rel="noopener">陈云龙学长</a></p>
<h2 id="初级版"><a href="#初级版" class="headerlink" title="初级版"></a>初级版</h2><h3 id="图片放哪里"><a href="#图片放哪里" class="headerlink" title="图片放哪里"></a>图片放哪里</h3><p>在与md文件的同一个目录下，新建与md文件同名的文件夹，<br><img src="/image/2016-09-25-addImg/new_folder.png" alt><br>然后把图片放进去</p>
<h3 id="代码怎么写"><a href="#代码怎么写" class="headerlink" title="代码怎么写"></a>代码怎么写</h3><p>md文件里只需要在想加图片的地方这样写<br>（比如我的图片名字是dog.jpg）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](dog.jpg) <span class="comment">#[]里面是alt text 写不写都行</span></span><br></pre></td></tr></table></figure></p>
<p>不需要指定路径~<br>因为执行hexo g指令的时候，这张图片会与对应的这篇博客生成的html文件放在同一目录下（在public文件夹里 感兴趣的话可以自己去看一下~）</p>
<h3 id="还要改个配置"><a href="#还要改个配置" class="headerlink" title="还要改个配置"></a>还要改个配置</h3><p>打开根目录下的config.yml文件（注意不是themes文件夹里面的那个！别搞错了~~）<br>找到里面的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: <span class="literal">false</span> <span class="comment">#个人文件夹是否启用</span></span><br></pre></td></tr></table></figure></p>
<p>把false改成true~</p>
<hr>
<h2 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h2><p>上面是我一开始学会的方法，不过有个问题，就是在博客主页的界面看不到图片<br><img src="/image/2016-09-25-addImg/wrong.png" alt><br>所以针对第一步第二步有点小改动。</p>
<h3 id="图片放哪里-1"><a href="#图片放哪里-1" class="headerlink" title="图片放哪里"></a>图片放哪里</h3><p>在你的博客的文件夹里有一个叫 source的文件夹，在source里新建一个用来放图片的文件夹，名字随意。比如我的叫image<br><img src="/image/2016-09-25-addImg/new_folder1.0_.png" alt><br>然后把图片放进去。<br>也可以再在image里给每篇博客建一个文件夹方便管理，当然这个随意啦~<br>我是这样放我的图片的~<br><img src="/image/2016-09-25-addImg/pic.png" alt></p>
<h3 id="代码怎么写-1"><a href="#代码怎么写-1" class="headerlink" title="代码怎么写"></a>代码怎么写</h3><p>md文件里只需要在想加图片的地方这样写<br>（比如我的图片名字是toefl.png）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![](/image/2016-09-25-TOEFL/toefl.png)</span><br><span class="line"><span class="comment">#[]里面是alt text 写不写都行</span></span><br><span class="line"><span class="comment">#要注意image前面的“/”一定要写，表示根目录~</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>初级版方法在主页看不到图片，是因为生成的public文件夹里，与主页html文件 同路径下是没有各篇博客的图片的。<br>而改进版的方法通过指定image文件夹，就使得各个html文件都可以访问到那些图片啦~</p>
<p>Done~^ ^</p>
]]></content>
      
        
        <tags>
            
            <tag> web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第一次考TOEFL~]]></title>
      <url>https://disinuo.me/2016/09/25/2016-09-25-TOEFL/</url>
      <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天上午，去考托福啦~<br>总体来说还是比预想的好一点的，因为实际上真正准备的时间是。。从开学到昨天。。就是。。不到一个月。。所以很虚导致预想很低<br>总结下自己的感想好了^ ^<br><a id="more"></a><br>首先。整场考下来，真的没想象那么累，中间休息也不饿，也不太有之前以为的【身体被掏空】的感觉。。。不过面对电脑太久倒确实有点头晕晕的</p>
<p>加试的是听力，而且按大家出去休息的时间来看应该大部分同学都是加试的听力。</p>
<h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p>阅读淡定的做 时间还是够的~【嗯必须要羞耻的承认 我一开始刷题的时候一个小时只能做两篇orz。。。后来在网上找了点做题技巧之类的，再加上刷了好多题逐渐找到了感觉~有一次做完3篇剩了8分钟！(此处应该有掌声！)虽然那是个偶然哈哈~不过基本都可以在规定时间内做完了】</p>
<p>之前自己模考的时候偶尔会用ctrl+f找单词定位。。。还在想考试的时候不会也可以用吧~~然后，哦，果然不可以用。。。</p>
<p>还有不造你们有没有注意过阅读部分前面的说明里有提到过 可能会有带下划线的单词，点击可以看到它的意思<br>就是下面这句<br><img src="/image/2016-09-25-TOEFL/toefl.png" alt><br>都是骗纸。我做这么多篇怎么从来没遇到过。。。亏我第一次看到这句话的时候还感慨TOEFL还挺人性化</p>
<h3 id="听力"><a href="#听力" class="headerlink" title="听力"></a>听力</h3><p>加试了一个section的听力，就是一篇conversation两篇lecture，一共大概30分钟</p>
<p>考完两个section的听力之后觉得再听下去可能要蒙掉，于是接下来的几个continue我都没有点，等它自己时间到跳过去的 哈哈~多少也算是争取出来一点休息的时间</p>
<p>听力我一直不太擅长的，不过还是有点经验可以分享下~</p>
<p>比如lecture类的，一般学生提问后 教授的回答，以及教授提问后 同学的回答，都是容易出题的地方。还有听力材料快结束的地方也容易出题，好多同学 当然包括我 听到最后容易走神，然后针对那部分出的那道题就跪了。。。还有一些，比如教授说话的时候，Because 然后顿一下 ，后面这一段一般也容易出题的~【这样看来好像还挺人性化的哈哈，仿佛在提示我们一样】</p>
<p>个人觉得conversation类的相对容易一点，因为一般对话内容比较贴近生活不容易走神，只要整篇跟着听下来再记一些细节一般应该没什么问题~</p>
<h3 id="口语"><a href="#口语" class="headerlink" title="口语"></a>口语</h3><p>都是泪的part。。。觉得前两篇最难。。。</p>
<p>最开始准备TOEFL的时候还以为后面几道口语比较难，毕竟又考察听力、阅读能力的。<br>但后来才发现。。这种其实认真看认真听都还好，起码你知道要说什么。。。但是前面两道自由发挥的，要是是没见过的题目，再紧张一点，15秒根本不够好嘛orz。。。这一次前两题就血崩</p>
<p>哦不过自己比较满意的一点就是 说的时候没有羞涩，真的这点很重要的，一定至少要用平时讲话的音量说，不然听起来会很怂，而且可能效果也会不太好。不要觉得自己讲的不好，就不好意思说怕别人笑话，别人都在想自己的题目呢那有空听你~</p>
<p>另外后面几道也都是套路啦</p>
<p>比如第3题，就是学校新搞了一个什么政策，先45秒看一段有关这个政策内容的材料，然后听一段两个学生讨论它，支持不支持的我都遇到过。</p>
<p>在看阅读材料的时候要注意【点】。<br>它的大概结构就是先总体说下政策是什么，然后说几点这个决定的优点，一般两到三个。<br>因为后面的听力里面 学生的观点基本是针对这几点给出自己的看法。<br>所以阅读材料相当于先给我们透露了后面听力的主要内容啦~</p>
<p>第5题，两个学生聊天，一个遇到了个trouble，然后他俩会聊出两个solution，然后让你总结trouble、solutions、和你建议哪个solution。<br>每个solution都有优缺点的，一定要听全面。<br>然后20秒准备的时候就要想好自己支持哪个，再简单说点原因~</p>
<p>第6题，我一开始练的时候，最摸不清套路，<br>因为是一篇不一定关于什么的讲座，所以完全不知道会问什么，听的时候就没有侧重点。</p>
<p>但后来我发现。。。<br>教授从某个地方开始，会特别明显的说到first，second，third【好像一般都是三点~】，<br>这就是答题的点~~~<br>记下每一点的主旨句（一般就是第一句），<br>以及尽量多的细节~（一般每一点都会有一个例子，，，但我经常手速不够记不完orz）</p>
<h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>第一篇，看文章的时候除了每一段的主旨句，细节也要记点的，这样有助于后面听力的理解。<br>而且我觉得时间是足够的~</p>
<p>然后听的时候注意记细节！细节！因为主旨也不用记了 一般教授都是反对文章的，每一段都跟文章主旨相反就好~写作的时候文章会再度出现哒~~</p>
<p>第二篇嘛就没啥经验了，我也就只练了一次。写之前先大概写下提纲吧，起码文章结构要清晰，一二三点展开来说</p>
<h3 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h3><p>每个part都考完之后 界面会有一个对话框，<br>问你report还是cancel（好像是这两个单词？。。。）<br>反正大概就是问你要不要这次的成绩，<br>听说有同学没仔细看 选了cancel的。。。<br>好了你3个多小时的奋战就算白玩了 手动微笑。</p>
<p>所以记得要选report！！~</p>
<p>考前会签一个保密协议</p>
<p>考前还要照个像，然后才电脑随机分配考位（照相这个没听人提过不知道是不是不同考场不一样哈~）</p>
<p>没啦~</p>
]]></content>
      
        
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[噔噔噔有自己的博客啦！^o^]]></title>
      <url>https://disinuo.me/2016/09/16/2016-09-16-myfirst/</url>
      <content type="html"><![CDATA[<p>真可怕弄到这么晚。。。<br>照着<a href="http://www.cylong.com/blog/2016/04/19/hexo-git/" target="_blank" rel="noopener">陈云龙学长的博客教程</a>~用hexo+github总算是搭建出了博客的整体框架<br>整体还算顺利~<br><a id="more"></a><br>不过其中有一个问题耗费了好长时间。知道真相的我也是。。。orz：<br>在git bash里面输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d <span class="comment">#部署</span></span><br></pre></td></tr></table></figure></p>
<p>一直没反应。。也不报错。。。<br>后来还是靠度娘，发现原来是博客本地文件夹下的 _config.yml文件里面，修改deploy属性的时候，要注意每个冒号后面都要有一个空格</p>
]]></content>
      
        
        <tags>
            
            <tag> web </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
